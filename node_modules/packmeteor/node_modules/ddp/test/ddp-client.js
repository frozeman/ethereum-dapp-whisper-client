var assert = require('assert'),
    sinon  = require('sinon'),
    rewire = require('rewire'),
    events = require('events'),
    EJSON  = require('meteor-ejson');

var DDPClient = rewire("../lib/ddp-client");

var wsConstructor, wsMock;

function prepareMocks() {
  wsMock = new events.EventEmitter();

  wsConstructor = sinon.stub();
  wsConstructor.returns(wsMock);
  DDPClient.__set__('WebSocket', wsConstructor);
}


describe("Connect to remote server", function() {
  beforeEach(function() {
    prepareMocks();
  });

  it('should connect to localhost by default', function() {
    new DDPClient().connect();

    assert(wsConstructor.calledOnce);
    assert(wsConstructor.calledWithNew());
    assert(wsConstructor.call);
    assert.deepEqual(wsConstructor.args, [['ws://localhost:3000/websocket']]);
  });
  it('should connect to the provided host', function() {
    new DDPClient({'host': 'myserver.com'}).connect();
    assert.deepEqual(wsConstructor.args, [['ws://myserver.com:3000/websocket']]);
  });
  it('should connect to the provided host and port', function() {
    new DDPClient({'host': 'myserver.com', 'port': 42}).connect();
    assert.deepEqual(wsConstructor.args, [['ws://myserver.com:42/websocket']]);
  });
  it('should use ssl if the port is 443', function() {
    new DDPClient({'host': 'myserver.com', 'port': 443}).connect();
    assert.deepEqual(wsConstructor.args, [['wss://myserver.com:443/websocket']]);
  });
});

describe('Automatic reconnection', function() {
  beforeEach(function() {
    prepareMocks();
  });


  /* We should be able to get this test to work with clock.tick() but for some weird 
     reasons it does not work. See: https://github.com/cjohansen/Sinon.JS/issues/283
   */
  it('should reconnect when the connection fails', function(done) {
    var ddpclient = new DDPClient({ auto_reconnect_timer: 10 });

    ddpclient.connect();
    wsMock.emit('error', {});

    // At this point, the constructor should have been called only once.
    assert(wsConstructor.calledOnce);

    setTimeout(function() {
      // Now the constructor should have been called twice
      assert(wsConstructor.calledTwice);
      done();
    }, 15);
  });
});

describe("Network errors", function() {
  beforeEach(function() {
    prepareMocks();
  });

  // For some weird reasons (hard to reproduce) it happens that we try to send a message and
  // get an exception throws at us because the connection is not opened anymore.
  it ('should not crash when WebSocket throws a "not-opened" error', function() {
    // Simulates the error generated by WebSocket if the connection is not opened:
    // WebSocket.send (ws/lib/WebSocket.js:175:16)
    wsMock.send = function(data, options, cb) {
      if (typeof options == 'function') {
        cb = options;
        options = {};
      }
      // if (this.readyState != WebSocket.OPEN)
      if (typeof cb == 'function') cb(new Error('not opened'));
      else throw new Error('not opened');
    };

    var ddpclient = new DDPClient();
    ddpclient.connect();

    var errorCB = sinon.spy();
    ddpclient.on('socket-error', errorCB);
    var callCB = sinon.spy();

    ddpclient.call('aServerMethod', [42], callCB);

    // First of all, the previous call should not throw anything.
    // The method callback should not be called
    // The socket-error event should not be triggered now
    // (but it will be triggered later by the socket)
    assert(!callCB.calledOnce);
    assert(!errorCB.calledOnce);
  });
});


describe('EJSON', function() {

  var DDPMessage = '{"msg":"added","collection":"posts","id":"2trpvcQ4pn32ZYXco","fields":{"date":{"$date":1371591394454},"bindata":{"$binary":"QUJDRA=="}}}';
  var EJSONObject = EJSON.parse(DDPMessage);

  it('should not be enabled by default', function(done) {
    var ddpclient = new DDPClient();

    assert(!ddpclient.use_ejson);

    done();
  });

  it('should not be used when disabled', function(done) {
    var ddpclient = new DDPClient({ use_ejson : false });

    assert(!ddpclient.use_ejson);

    ddpclient._message(DDPMessage);

    // ensure received dates not decoded from EJSON
    assert.deepEqual(ddpclient.collections.posts['2trpvcQ4pn32ZYXco'].date, {"$date":1371591394454});

    // ensure received binary data not decoded from EJSON date
    assert.deepEqual(ddpclient.collections.posts['2trpvcQ4pn32ZYXco'].bindata, {"$binary":"QUJDRA=="});

    ddpclient.socket = {};
    ddpclient.socket.send = function (opts) {
      // ensure sent dates not encoded into EJSON
      assert(opts.indexOf("date")          !== -1);
      assert(opts.indexOf("$date")         === -1);
      assert(opts.indexOf("1371591394454") === -1);

      // ensure sent binary data not encoded into EJSON
      assert(opts.indexOf("bindata")       !== -1);
      assert(opts.indexOf("$binary")       === -1);
      assert(opts.indexOf("QUJDRA==")      === -1);
    };

    ddpclient._send(EJSONObject.fields);

    done();
  });

  it('should be used if specifically enabled', function(done) {
    var ddpclient = new DDPClient({ use_ejson : true });

    assert(ddpclient.use_ejson);

    ddpclient._message(DDPMessage);

    assert.deepEqual(ddpclient.collections.posts['2trpvcQ4pn32ZYXco'].date, new Date(1371591394454));

    assert.deepEqual(ddpclient.collections.posts['2trpvcQ4pn32ZYXco'].bindata, new Uint8Array([65, 66, 67, 68]));

    ddpclient.socket = {};
    ddpclient.socket.send = function (opts) {
      assert(opts.indexOf("date")          !== -1);
      assert(opts.indexOf("$date")         !== -1);
      assert(opts.indexOf("1371591394454") !== -1);

      assert(opts.indexOf("bindata")       !== -1);
      assert(opts.indexOf("$binary")       !== -1);
      assert(opts.indexOf("QUJDRA==")      !== -1);
    };

    ddpclient._send(EJSONObject.fields);

    done();
  });

});

