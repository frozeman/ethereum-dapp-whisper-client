{"version":3,"file":"/packages/wizonesolutions:underscore-string.js","sources":["wizonesolutions:underscore-string/pre.js","wizonesolutions:underscore-string/lib/underscore.string/lib/underscore.string.js","wizonesolutions:underscore-string/post.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,gF;AACA,qE;AACA,a;;;;;;;;;;;;;;;;;;;ACFA,qB;AACA,gE;AACA,iF;AACA,6D;AACA,iE;AACA,mB;;AAEA,wB;AACA,e;;AAEA,+B;;AAEA,yC;AACA,mD;AACA,iD;;AAEA,iE;;AAEA,qC;AACA,2B;AACA,oB;AACA,qB;AACA,iC;AACA,4B;AACA,K;AACA,kB;AACA,I;;AAEA,uB;;AAEA,kD;AACA,2B;AACA,mB;AACA,+B;AACA,+B;AACA,Q;AACA,qD;AACA,I;;AAEA,yB;AACA,mC;AACA,2C;AACA,mC;AACA,8C;AACA,4B;AACA,6B;AACA,uD;AACA,sD;AACA,K;AACA,G;;AAEA,qB;AACA,Y;AACA,Y;AACA,c;AACA,a;AACA,a;AACA,I;;AAEA,+B;AACA,0E;AACA,mC;;AAEA,uC;AACA,kE;AACA,I;AACA,yE;AACA,yB;;AAEA,6B;AACA,iC;AACA,iF;AACA,K;;AAEA,+B;;AAEA,iC;AACA,2D;AACA,wE;AACA,O;AACA,qF;AACA,M;;AAEA,oD;AACA,qI;AACA,yC;AACA,4C;AACA,qC;AACA,qC;AACA,S;AACA,yC;AACA,6D;AACA,6C;AACA,+B;AACA,mD;AACA,qD;AACA,kG;AACA,e;AACA,qC;AACA,a;AACA,kE;AACA,iC;AACA,W;AACA,kD;AACA,iC;AACA,W;;AAEA,qE;AACA,iG;AACA,W;AACA,6B;AACA,mD;AACA,4D;AACA,qD;AACA,gG;AACA,kG;AACA,mD;AACA,wG;AACA,iD;AACA,oD;AACA,kE;AACA,W;AACA,kF;AACA,sF;AACA,qD;AACA,sE;AACA,wD;AACA,S;AACA,O;AACA,6B;AACA,M;;AAEA,0B;;AAEA,sC;AACA,iE;AACA,oB;AACA,wD;AACA,oC;AACA,S;AACA,4D;AACA,+B;AACA,S;AACA,wI;AACA,yB;AACA,2B;AACA,gF;AACA,yF;AACA,8C;AACA,uG;AACA,+F;AACA,kD;AACA,iB;AACA,yF;AACA,kD;AACA,iB;AACA,sB;AACA,sD;AACA,iB;AACA,e;AACA,a;AACA,kB;AACA,kD;AACA,a;AACA,kC;AACA,W;AACA,gB;AACA,2B;AACA,W;AACA,gC;AACA,2G;AACA,W;AACA,iC;AACA,S;AACA,c;AACA,8C;AACA,S;AACA,+C;AACA,O;AACA,wB;AACA,M;;AAEA,sB;AACA,O;;;;AAIA,+B;;AAEA,Y;;AAEA,qB;;AAEA,2B;AACA,gC;AACA,iC;AACA,M;;AAEA,6B;AACA,iC;AACA,oD;AACA,M;;AAEA,+B;AACA,2C;AACA,wD;AACA,M;;AAEA,8B;AACA,iC;AACA,wB;AACA,oB;AACA,gF;AACA,M;;AAEA,yB;AACA,gD;AACA,M;;AAEA,iC;AACA,kD;;AAEA,wB;AACA,8B;;AAEA,oB;AACA,gB;AACA,+B;;AAEA,oB;AACA,uC;AACA,8B;AACA,gB;AACA,sB;AACA,O;;AAEA,mB;AACA,M;;AAEA,0B;AACA,iC;AACA,mC;AACA,M;;AAEA,6B;AACA,iC;AACA,oD;AACA,yE;AACA,S;AACA,M;;AAEA,+B;AACA,iC;AACA,wG;AACA,M;;AAEA,iC;AACA,iC;AACA,6E;AACA,kB;;AAEA,wC;AACA,yC;AACA,mE;AACA,6D;AACA,0D;AACA,iD;AACA,gB;AACA,wB;AACA,S;AACA,S;AACA,M;;AAEA,gC;AACA,iC;AACA,uE;AACA,M;;AAEA,8C;AACA,8B;AACA,yC;AACA,0B;AACA,M;;AAEA,qC;AACA,0C;AACA,M;;AAEA,mC;AACA,qC;AACA,oC;AACA,gD;AACA,M;;AAEA,sB;AACA,uC;AACA,iC;;AAEA,4C;;AAEA,kC;AACA,M;;AAEA,0B;AACA,iC;AACA,qC;AACA,M;;AAEA,2B;AACA,8C;AACA,M;;AAEA,sC;AACA,qC;AACA,sD;AACA,iD;AACA,mF;AACA,M;;AAEA,kC;AACA,mC;AACA,oD;AACA,6C;AACA,uF;AACA,M;;AAEA,wB;AACA,iC;AACA,wB;AACA,sF;AACA,M;;AAEA,4B;AACA,iC;AACA,uC;AACA,kF;AACA,M;;AAEA,4B;AACA,0G;AACA,M;;AAEA,+B;AACA,uG;AACA,M;;AAEA,6B;AACA,4F;AACA,M;;AAEA,4B;AACA,gF;AACA,M;;AAEA,4B;AACA,sF;AACA,M;;AAEA,oC;AACA,iC;AACA,iE;AACA,mD;AACA,mG;AACA,M;;AAEA,qC;AACA,iC;AACA,yE;AACA,mD;AACA,yE;AACA,M;;AAEA,qC;AACA,iC;AACA,2E;AACA,mD;AACA,oE;AACA,M;;AAEA,iD;AACA,iC;AACA,4D;AACA,wB;AACA,4E;AACA,M;;AAEA,O;AACA,mD;AACA,4D;AACA,6B;AACA,O;AACA,2C;AACA,iC;;AAEA,2C;AACA,6D;;AAEA,2C;;AAEA,wF;AACA,6G;;AAEA,0D;AACA,mD;AACA,U;AACA,kE;;AAEA,oG;AACA,M;;AAEA,qC;AACA,qC;AACA,+D;AACA,M;;AAEA,8C;AACA,2C;AACA,wB;;AAEA,sB;;AAEA,kB;AACA,qB;AACA,iC;AACA,kC;;AAEA,oB;AACA,qB;AACA,uC;AACA,iD;AACA,oB;AACA,uC;AACA,6D;AACA,4D;AACA,0B;AACA,uC;AACA,iD;AACA,S;AACA,M;;AAEA,yC;AACA,yC;AACA,M;;AAEA,yC;AACA,kD;AACA,M;;AAEA,0C;AACA,iD;AACA,M;;AAEA,qB;;AAEA,kC;AACA,wB;AACA,uC;AACA,M;;AAEA,uC;AACA,yB;AACA,yB;AACA,sD;AACA,+D;AACA,M;;AAEA,sD;AACA,qD;;AAEA,qC;AACA,kD;;AAEA,sD;AACA,4D;;AAEA,2E;AACA,M;;AAEA,iC;AACA,iC;AACA,+D;AACA,6C;AACA,gE;AACA,M;;AAEA,qC;AACA,iC;AACA,+D;AACA,iD;AACA,gE;AACA,M;;AAEA,gC;AACA,iC;AACA,+D;AACA,6C;AACA,4C;AACA,M;;AAEA,oC;AACA,iC;AACA,kD;AACA,qC;AACA,4C;AACA,M;;AAEA,mE;AACA,oC;AACA,+C;AACA,kD;;AAEA,0F;;AAEA,oF;AACA,M;;AAEA,kC;AACA,uC;AACA,qB;AACA,2C;AACA,M;;AAEA,4B;AACA,iC;;AAEA,2D;AACA,2D;AACA,6D;;AAEA,iE;AACA,oC;AACA,uC;AACA,S;;AAEA,wD;AACA,M;;AAEA,sC;AACA,8C;AACA,M;;AAEA,qC;AACA,gD;AACA,M;;AAEA,uC;AACA,mC;AACA,kE;AACA,yC;AACA,sB;AACA,M;;AAEA,yB;AACA,sB;;AAEA,8B;AACA,iG;AACA,kC;AACA,O;;AAEA,oB;AACA,M;;AAEA,0C;AACA,iC;;AAEA,kB;;AAEA,gE;AACA,gE;;AAEA,uD;AACA,4D;AACA,oC;AACA,M;;AAEA,qC;AACA,iC;AACA,2B;AACA,0B;;AAEA,4C;AACA,6D;AACA,6D;AACA,yD;;AAEA,sC;AACA,2C;;AAEA,qB;AACA,qC;AACA,4B;AACA,uC;AACA,4C;AACA,iC;AACA,W;AACA,gC;AACA,S;AACA,O;;AAEA,4C;AACA,+C;;AAEA,kC;AACA,M;;AAEA,uC;AACA,iD;AACA,mD;AACA,mD;;AAEA,+C;;AAEA,oC;;AAEA,4C;AACA,gD;AACA,qB;AACA,0D;AACA,2B;AACA,gB;AACA,qE;AACA,c;AACA,0B;;AAEA,4B;AACA,6B;AACA,S;;AAEA,2B;AACA,M;;AAEA,uD;AACA,kD;AACA,gD;AACA,yB;AACA,mE;AACA,sE;AACA,K;AACA,I;;AAEA,Y;;AAEA,wB;AACA,yB;AACA,yB;AACA,yB;AACA,wB;AACA,wB;AACA,2B;AACA,yB;AACA,6B;;AAEA,c;;AAEA,+B;AACA,uC;AACA,wD;AACA,0B;;AAEA,oB;AACA,G;;AAEA,yC;AACA,iD;AACA,8D;;;AAGA,4C;AACA,yC;AACA,wB;AACA,kC;AACA,gB;;;;;;;;;;;;;;;;;;;AChqBA,6E;AACA,gE;AACA,gB;;AAEA,oE;AACA,W;;AAEA,yB;;AAEA,gF;AACA,e;AACA,wD","sourcesContent":["// Define an object named exports. This will cause underscore.js to put `_` as a\n// field on it, instead of in the global namespace. See also post.js.\nexports = {};\n","//  Underscore.string\n//  (c) 2010 Esa-Matti Suuronen <esa-matti aet suuronen dot org>\n//  Underscore.string is freely distributable under the terms of the MIT license.\n//  Documentation: https://github.com/epeli/underscore.string\n//  Some code is borrowed from MooTools and Alexandru Marasteanu.\n//  Version '2.3.3'\n\n!function(root, String){\n  'use strict';\n\n  // Defining helper functions.\n\n  var nativeTrim = String.prototype.trim;\n  var nativeTrimRight = String.prototype.trimRight;\n  var nativeTrimLeft = String.prototype.trimLeft;\n\n  var parseNumber = function(source) { return source * 1 || 0; };\n\n  var strRepeat = function(str, qty){\n    if (qty < 1) return '';\n    var result = '';\n    while (qty > 0) {\n      if (qty & 1) result += str;\n      qty >>= 1, str += str;\n    }\n    return result;\n  };\n\n  var slice = [].slice;\n\n  var defaultToWhiteSpace = function(characters) {\n    if (characters == null)\n      return '\\\\s';\n    else if (characters.source)\n      return characters.source;\n    else\n      return '[' + _s.escapeRegExp(characters) + ']';\n  };\n\n  // Helper for toBoolean\n  function boolMatch(s, matchers) {\n    var i, matcher, down = s.toLowerCase();\n    matchers = [].concat(matchers);\n    for (i = 0; i < matchers.length; i += 1) {\n      matcher = matchers[i];\n      if (!matcher) continue;\n      if (matcher.test && matcher.test(s)) return true;\n      if (matcher.toLowerCase() === down) return true;\n    }\n  }\n\n  var escapeChars = {\n    lt: '<',\n    gt: '>',\n    quot: '\"',\n    amp: '&',\n    apos: \"'\"\n  };\n\n  var reversedEscapeChars = {};\n  for(var key in escapeChars) reversedEscapeChars[escapeChars[key]] = key;\n  reversedEscapeChars[\"'\"] = '#39';\n\n  // sprintf() for JavaScript 0.7-beta1\n  // http://www.diveintojavascript.com/projects/javascript-sprintf\n  //\n  // Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>\n  // All rights reserved.\n\n  var sprintf = (function() {\n    function get_type(variable) {\n      return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();\n    }\n\n    var str_repeat = strRepeat;\n\n    var str_format = function() {\n      if (!str_format.cache.hasOwnProperty(arguments[0])) {\n        str_format.cache[arguments[0]] = str_format.parse(arguments[0]);\n      }\n      return str_format.format.call(null, str_format.cache[arguments[0]], arguments);\n    };\n\n    str_format.format = function(parse_tree, argv) {\n      var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;\n      for (i = 0; i < tree_length; i++) {\n        node_type = get_type(parse_tree[i]);\n        if (node_type === 'string') {\n          output.push(parse_tree[i]);\n        }\n        else if (node_type === 'array') {\n          match = parse_tree[i]; // convenience purposes only\n          if (match[2]) { // keyword argument\n            arg = argv[cursor];\n            for (k = 0; k < match[2].length; k++) {\n              if (!arg.hasOwnProperty(match[2][k])) {\n                throw new Error(sprintf('[_.sprintf] property \"%s\" does not exist', match[2][k]));\n              }\n              arg = arg[match[2][k]];\n            }\n          } else if (match[1]) { // positional argument (explicit)\n            arg = argv[match[1]];\n          }\n          else { // positional argument (implicit)\n            arg = argv[cursor++];\n          }\n\n          if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {\n            throw new Error(sprintf('[_.sprintf] expecting number but found %s', get_type(arg)));\n          }\n          switch (match[8]) {\n            case 'b': arg = arg.toString(2); break;\n            case 'c': arg = String.fromCharCode(arg); break;\n            case 'd': arg = parseInt(arg, 10); break;\n            case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;\n            case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;\n            case 'o': arg = arg.toString(8); break;\n            case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;\n            case 'u': arg = Math.abs(arg); break;\n            case 'x': arg = arg.toString(16); break;\n            case 'X': arg = arg.toString(16).toUpperCase(); break;\n          }\n          arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);\n          pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';\n          pad_length = match[6] - String(arg).length;\n          pad = match[6] ? str_repeat(pad_character, pad_length) : '';\n          output.push(match[5] ? arg + pad : pad + arg);\n        }\n      }\n      return output.join('');\n    };\n\n    str_format.cache = {};\n\n    str_format.parse = function(fmt) {\n      var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;\n      while (_fmt) {\n        if ((match = /^[^\\x25]+/.exec(_fmt)) !== null) {\n          parse_tree.push(match[0]);\n        }\n        else if ((match = /^\\x25{2}/.exec(_fmt)) !== null) {\n          parse_tree.push('%');\n        }\n        else if ((match = /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {\n          if (match[2]) {\n            arg_names |= 1;\n            var field_list = [], replacement_field = match[2], field_match = [];\n            if ((field_match = /^([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n              field_list.push(field_match[1]);\n              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                if ((field_match = /^\\.([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n                  field_list.push(field_match[1]);\n                }\n                else if ((field_match = /^\\[(\\d+)\\]/.exec(replacement_field)) !== null) {\n                  field_list.push(field_match[1]);\n                }\n                else {\n                  throw new Error('[_.sprintf] huh?');\n                }\n              }\n            }\n            else {\n              throw new Error('[_.sprintf] huh?');\n            }\n            match[2] = field_list;\n          }\n          else {\n            arg_names |= 2;\n          }\n          if (arg_names === 3) {\n            throw new Error('[_.sprintf] mixing positional and named placeholders is not (yet) supported');\n          }\n          parse_tree.push(match);\n        }\n        else {\n          throw new Error('[_.sprintf] huh?');\n        }\n        _fmt = _fmt.substring(match[0].length);\n      }\n      return parse_tree;\n    };\n\n    return str_format;\n  })();\n\n\n\n  // Defining underscore.string\n\n  var _s = {\n\n    VERSION: '2.3.0',\n\n    isBlank: function(str){\n      if (str == null) str = '';\n      return (/^\\s*$/).test(str);\n    },\n\n    stripTags: function(str){\n      if (str == null) return '';\n      return String(str).replace(/<\\/?[^>]+>/g, '');\n    },\n\n    capitalize : function(str){\n      str = str == null ? '' : String(str);\n      return str.charAt(0).toUpperCase() + str.slice(1);\n    },\n\n    chop: function(str, step){\n      if (str == null) return [];\n      str = String(str);\n      step = ~~step;\n      return step > 0 ? str.match(new RegExp('.{1,' + step + '}', 'g')) : [str];\n    },\n\n    clean: function(str){\n      return _s.strip(str).replace(/\\s+/g, ' ');\n    },\n\n    count: function(str, substr){\n      if (str == null || substr == null) return 0;\n\n      str = String(str);\n      substr = String(substr);\n\n      var count = 0,\n        pos = 0,\n        length = substr.length;\n\n      while (true) {\n        pos = str.indexOf(substr, pos);\n        if (pos === -1) break;\n        count++;\n        pos += length;\n      }\n\n      return count;\n    },\n\n    chars: function(str) {\n      if (str == null) return [];\n      return String(str).split('');\n    },\n\n    swapCase: function(str) {\n      if (str == null) return '';\n      return String(str).replace(/\\S/g, function(c){\n        return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();\n      });\n    },\n\n    escapeHTML: function(str) {\n      if (str == null) return '';\n      return String(str).replace(/[&<>\"']/g, function(m){ return '&' + reversedEscapeChars[m] + ';'; });\n    },\n\n    unescapeHTML: function(str) {\n      if (str == null) return '';\n      return String(str).replace(/\\&([^;]+);/g, function(entity, entityCode){\n        var match;\n\n        if (entityCode in escapeChars) {\n          return escapeChars[entityCode];\n        } else if (match = entityCode.match(/^#x([\\da-fA-F]+)$/)) {\n          return String.fromCharCode(parseInt(match[1], 16));\n        } else if (match = entityCode.match(/^#(\\d+)$/)) {\n          return String.fromCharCode(~~match[1]);\n        } else {\n          return entity;\n        }\n      });\n    },\n\n    escapeRegExp: function(str){\n      if (str == null) return '';\n      return String(str).replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n    },\n\n    splice: function(str, i, howmany, substr){\n      var arr = _s.chars(str);\n      arr.splice(~~i, ~~howmany, substr);\n      return arr.join('');\n    },\n\n    insert: function(str, i, substr){\n      return _s.splice(str, i, 0, substr);\n    },\n\n    include: function(str, needle){\n      if (needle === '') return true;\n      if (str == null) return false;\n      return String(str).indexOf(needle) !== -1;\n    },\n\n    join: function() {\n      var args = slice.call(arguments),\n        separator = args.shift();\n\n      if (separator == null) separator = '';\n\n      return args.join(separator);\n    },\n\n    lines: function(str) {\n      if (str == null) return [];\n      return String(str).split(\"\\n\");\n    },\n\n    reverse: function(str){\n      return _s.chars(str).reverse().join('');\n    },\n\n    startsWith: function(str, starts){\n      if (starts === '') return true;\n      if (str == null || starts == null) return false;\n      str = String(str); starts = String(starts);\n      return str.length >= starts.length && str.slice(0, starts.length) === starts;\n    },\n\n    endsWith: function(str, ends){\n      if (ends === '') return true;\n      if (str == null || ends == null) return false;\n      str = String(str); ends = String(ends);\n      return str.length >= ends.length && str.slice(str.length - ends.length) === ends;\n    },\n\n    succ: function(str){\n      if (str == null) return '';\n      str = String(str);\n      return str.slice(0, -1) + String.fromCharCode(str.charCodeAt(str.length-1) + 1);\n    },\n\n    titleize: function(str){\n      if (str == null) return '';\n      str  = String(str).toLowerCase();\n      return str.replace(/(?:^|\\s|-)\\S/g, function(c){ return c.toUpperCase(); });\n    },\n\n    camelize: function(str){\n      return _s.trim(str).replace(/[-_\\s]+(.)?/g, function(match, c){ return c ? c.toUpperCase() : \"\"; });\n    },\n\n    underscored: function(str){\n      return _s.trim(str).replace(/([a-z\\d])([A-Z]+)/g, '$1_$2').replace(/[-\\s]+/g, '_').toLowerCase();\n    },\n\n    dasherize: function(str){\n      return _s.trim(str).replace(/([A-Z])/g, '-$1').replace(/[-_\\s]+/g, '-').toLowerCase();\n    },\n\n    classify: function(str){\n      return _s.titleize(String(str).replace(/[\\W_]/g, ' ')).replace(/\\s/g, '');\n    },\n\n    humanize: function(str){\n      return _s.capitalize(_s.underscored(str).replace(/_id$/,'').replace(/_/g, ' '));\n    },\n\n    trim: function(str, characters){\n      if (str == null) return '';\n      if (!characters && nativeTrim) return nativeTrim.call(str);\n      characters = defaultToWhiteSpace(characters);\n      return String(str).replace(new RegExp('^' + characters + '+|' + characters + '+$', 'g'), '');\n    },\n\n    ltrim: function(str, characters){\n      if (str == null) return '';\n      if (!characters && nativeTrimLeft) return nativeTrimLeft.call(str);\n      characters = defaultToWhiteSpace(characters);\n      return String(str).replace(new RegExp('^' + characters + '+'), '');\n    },\n\n    rtrim: function(str, characters){\n      if (str == null) return '';\n      if (!characters && nativeTrimRight) return nativeTrimRight.call(str);\n      characters = defaultToWhiteSpace(characters);\n      return String(str).replace(new RegExp(characters + '+$'), '');\n    },\n\n    truncate: function(str, length, truncateStr){\n      if (str == null) return '';\n      str = String(str); truncateStr = truncateStr || '...';\n      length = ~~length;\n      return str.length > length ? str.slice(0, length) + truncateStr : str;\n    },\n\n    /**\n     * _s.prune: a more elegant version of truncate\n     * prune extra chars, never leaving a half-chopped word.\n     * @author github.com/rwz\n     */\n    prune: function(str, length, pruneStr){\n      if (str == null) return '';\n\n      str = String(str); length = ~~length;\n      pruneStr = pruneStr != null ? String(pruneStr) : '...';\n\n      if (str.length <= length) return str;\n\n      var tmpl = function(c){ return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' '; },\n        template = str.slice(0, length+1).replace(/.(?=\\W*\\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'\n\n      if (template.slice(template.length-2).match(/\\w\\w/))\n        template = template.replace(/\\s*\\S+$/, '');\n      else\n        template = _s.rtrim(template.slice(0, template.length-1));\n\n      return (template+pruneStr).length > str.length ? str : str.slice(0, template.length)+pruneStr;\n    },\n\n    words: function(str, delimiter) {\n      if (_s.isBlank(str)) return [];\n      return _s.trim(str, delimiter).split(delimiter || /\\s+/);\n    },\n\n    pad: function(str, length, padStr, type) {\n      str = str == null ? '' : String(str);\n      length = ~~length;\n\n      var padlen  = 0;\n\n      if (!padStr)\n        padStr = ' ';\n      else if (padStr.length > 1)\n        padStr = padStr.charAt(0);\n\n      switch(type) {\n        case 'right':\n          padlen = length - str.length;\n          return str + strRepeat(padStr, padlen);\n        case 'both':\n          padlen = length - str.length;\n          return strRepeat(padStr, Math.ceil(padlen/2)) + str\n                  + strRepeat(padStr, Math.floor(padlen/2));\n        default: // 'left'\n          padlen = length - str.length;\n          return strRepeat(padStr, padlen) + str;\n        }\n    },\n\n    lpad: function(str, length, padStr) {\n      return _s.pad(str, length, padStr);\n    },\n\n    rpad: function(str, length, padStr) {\n      return _s.pad(str, length, padStr, 'right');\n    },\n\n    lrpad: function(str, length, padStr) {\n      return _s.pad(str, length, padStr, 'both');\n    },\n\n    sprintf: sprintf,\n\n    vsprintf: function(fmt, argv){\n      argv.unshift(fmt);\n      return sprintf.apply(null, argv);\n    },\n\n    toNumber: function(str, decimals) {\n      if (!str) return 0;\n      str = _s.trim(str);\n      if (!str.match(/^-?\\d+(?:\\.\\d+)?$/)) return NaN;\n      return parseNumber(parseNumber(str).toFixed(~~decimals));\n    },\n\n    numberFormat : function(number, dec, dsep, tsep) {\n      if (isNaN(number) || number == null) return '';\n\n      number = number.toFixed(~~dec);\n      tsep = typeof tsep == 'string' ? tsep : ',';\n\n      var parts = number.split('.'), fnums = parts[0],\n        decimals = parts[1] ? (dsep || '.') + parts[1] : '';\n\n      return fnums.replace(/(\\d)(?=(?:\\d{3})+$)/g, '$1' + tsep) + decimals;\n    },\n\n    strRight: function(str, sep){\n      if (str == null) return '';\n      str = String(str); sep = sep != null ? String(sep) : sep;\n      var pos = !sep ? -1 : str.indexOf(sep);\n      return ~pos ? str.slice(pos+sep.length, str.length) : str;\n    },\n\n    strRightBack: function(str, sep){\n      if (str == null) return '';\n      str = String(str); sep = sep != null ? String(sep) : sep;\n      var pos = !sep ? -1 : str.lastIndexOf(sep);\n      return ~pos ? str.slice(pos+sep.length, str.length) : str;\n    },\n\n    strLeft: function(str, sep){\n      if (str == null) return '';\n      str = String(str); sep = sep != null ? String(sep) : sep;\n      var pos = !sep ? -1 : str.indexOf(sep);\n      return ~pos ? str.slice(0, pos) : str;\n    },\n\n    strLeftBack: function(str, sep){\n      if (str == null) return '';\n      str += ''; sep = sep != null ? ''+sep : sep;\n      var pos = str.lastIndexOf(sep);\n      return ~pos ? str.slice(0, pos) : str;\n    },\n\n    toSentence: function(array, separator, lastSeparator, serial) {\n      separator = separator || ', ';\n      lastSeparator = lastSeparator || ' and ';\n      var a = array.slice(), lastMember = a.pop();\n\n      if (array.length > 2 && serial) lastSeparator = _s.rtrim(separator) + lastSeparator;\n\n      return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember;\n    },\n\n    toSentenceSerial: function() {\n      var args = slice.call(arguments);\n      args[3] = true;\n      return _s.toSentence.apply(_s, args);\n    },\n\n    slugify: function(str) {\n      if (str == null) return '';\n\n      var from  = \"ąàáäâãåæăćęèéëêìíïîłńòóöôõøśșțùúüûñçżź\",\n          to    = \"aaaaaaaaaceeeeeiiiilnoooooosstuuuunczz\",\n          regex = new RegExp(defaultToWhiteSpace(from), 'g');\n\n      str = String(str).toLowerCase().replace(regex, function(c){\n        var index = from.indexOf(c);\n        return to.charAt(index) || '-';\n      });\n\n      return _s.dasherize(str.replace(/[^\\w\\s-]/g, ''));\n    },\n\n    surround: function(str, wrapper) {\n      return [wrapper, str, wrapper].join('');\n    },\n\n    quote: function(str, quoteChar) {\n      return _s.surround(str, quoteChar || '\"');\n    },\n\n    unquote: function(str, quoteChar) {\n      quoteChar = quoteChar || '\"';\n      if (str[0] === quoteChar && str[str.length-1] === quoteChar)\n        return str.slice(1,str.length-1);\n      else return str;\n    },\n\n    exports: function() {\n      var result = {};\n\n      for (var prop in this) {\n        if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse)$/)) continue;\n        result[prop] = this[prop];\n      }\n\n      return result;\n    },\n\n    repeat: function(str, qty, separator){\n      if (str == null) return '';\n\n      qty = ~~qty;\n\n      // using faster implementation if separator is not needed;\n      if (separator == null) return strRepeat(String(str), qty);\n\n      // this one is about 300x slower in Google Chrome\n      for (var repeat = []; qty > 0; repeat[--qty] = str) {}\n      return repeat.join(separator);\n    },\n\n    naturalCmp: function(str1, str2){\n      if (str1 == str2) return 0;\n      if (!str1) return -1;\n      if (!str2) return 1;\n\n      var cmpRegex = /(\\.\\d+)|(\\d+)|(\\D+)/g,\n        tokens1 = String(str1).toLowerCase().match(cmpRegex),\n        tokens2 = String(str2).toLowerCase().match(cmpRegex),\n        count = Math.min(tokens1.length, tokens2.length);\n\n      for(var i = 0; i < count; i++) {\n        var a = tokens1[i], b = tokens2[i];\n\n        if (a !== b){\n          var num1 = parseInt(a, 10);\n          if (!isNaN(num1)){\n            var num2 = parseInt(b, 10);\n            if (!isNaN(num2) && num1 - num2)\n              return num1 - num2;\n          }\n          return a < b ? -1 : 1;\n        }\n      }\n\n      if (tokens1.length === tokens2.length)\n        return tokens1.length - tokens2.length;\n\n      return str1 < str2 ? -1 : 1;\n    },\n\n    levenshtein: function(str1, str2) {\n      if (str1 == null && str2 == null) return 0;\n      if (str1 == null) return String(str2).length;\n      if (str2 == null) return String(str1).length;\n\n      str1 = String(str1); str2 = String(str2);\n\n      var current = [], prev, value;\n\n      for (var i = 0; i <= str2.length; i++)\n        for (var j = 0; j <= str1.length; j++) {\n          if (i && j)\n            if (str1.charAt(j - 1) === str2.charAt(i - 1))\n              value = prev;\n            else\n              value = Math.min(current[j], current[j - 1], prev) + 1;\n          else\n            value = i + j;\n\n          prev = current[j];\n          current[j] = value;\n        }\n\n      return current.pop();\n    },\n\n    toBoolean: function(str, trueValues, falseValues) {\n      if (typeof str === \"number\") str = \"\" + str;\n      if (typeof str !== \"string\") return !!str;\n      str = _s.trim(str);\n      if (boolMatch(str, trueValues || [\"true\", \"1\"])) return true;\n      if (boolMatch(str, falseValues || [\"false\", \"0\"])) return false;\n    }\n  };\n\n  // Aliases\n\n  _s.strip    = _s.trim;\n  _s.lstrip   = _s.ltrim;\n  _s.rstrip   = _s.rtrim;\n  _s.center   = _s.lrpad;\n  _s.rjust    = _s.lpad;\n  _s.ljust    = _s.rpad;\n  _s.contains = _s.include;\n  _s.q        = _s.quote;\n  _s.toBool   = _s.toBoolean;\n\n  // Exporting\n\n  // CommonJS module is defined\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      module.exports = _s;\n\n    exports._s = _s;\n  }\n\n  // Register as a named module with AMD.\n  if (typeof define === 'function' && define.amd)\n    define('underscore.string', [], function(){ return _s; });\n\n\n  // Integrate with Underscore.js if defined\n  // or create our own underscore object.\n  root._ = root._ || {};\n  root._.string = root._.str = _s;\n}(this, String);\n","// This exports object was created in pre.js. Now copy the `_` object from it\n// into the package-scope variable `_`, which will get exported.\n_s = exports._s;\n\n// Mix in non-conflict functions to Underscore namespace if you want\n_.str = _s;\n\n_.mixin(_.str.exports());\n\n// All functions, including conflicting functions, will be available through the\n// _.str object\n_.str.include('Underscore.string', 'string'); // => true\n"]}