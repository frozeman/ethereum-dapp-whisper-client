{"version":3,"sources":["3stack:bignumber/bignumber.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,0E;;AAEA,0B;AACA,iB;;AAEA,M;AACA,yB;AACA,8D;AACA,6C;AACA,+D;AACA,uB;AACA,M;;AAEA,uF;;AAEA,M;AACA,oF;AACA,yF;AACA,O;;AAEA,M;AACA,iF;AACA,sF;AACA,+D;AACA,O;AACA,iE;;AAEA,8D;AACA,iE;;AAEA,kF;AACA,gE;;AAEA,U;AACA,2F;AACA,uF;AACA,uC;AACA,qC;AACA,0C;AACA,0C;AACA,sE;AACA,wE;AACA,0F;AACA,qF;AACA,qF;AACA,W;AACA,8D;;AAEA,qD;;AAEA,yF;AACA,0B;AACA,iE;;AAEA,uF;AACA,0B;AACA,gE;;AAEA,qC;;AAEA,8E;AACA,sC;AACA,kE;;AAEA,+E;AACA,uD;AACA,gE;;AAEA,oD;AACA,qE;AACA,qE;AACA,8E;;AAEA,4E;AACA,kB;AACA,kC;AACA,gC;AACA,yB;AACA,kC;AACA,8E;AACA,gC;AACA,U;;AAEA,yF;;AAEA,gC;AACA,oF;AACA,mB;AACA,e;AACA,+B;AACA,yD;AACA,4F;AACA,oB;AACA,sB;AACA,wB;AACA,2F;AACA,+B;;;AAGA,kB;;;AAGA,M;AACA,6B;AACA,8D;AACA,M;AACA,mD;AACA,8D;AACA,O;AACA,gC;AACA,uC;AACA,qB;;AAEA,gD;AACA,wE;;AAEA,qB;AACA,uC;;AAEA,8B;AACA,uB;AACA,gC;AACA,gC;AACA,wD;AACA,uB;AACA,a;AACA,oB;AACA,8D;;AAEA,sC;AACA,2C;AACA,wD;AACA,iE;AACA,2B;AACA,6B;AACA,uB;AACA,a;;AAEA,0B;AACA,qD;AACA,uC;AACA,oB;AACA,S;AACA,gB;;AAEA,+C;;AAEA,8B;AACA,+E;;AAEA,4E;AACA,gB;;AAEA,4E;AACA,oF;AACA,4B;AACA,uC;AACA,4E;AACA,a;AACA,2D;AACA,+F;;AAEA,8B;;AAEA,2F;AACA,kE;;AAEA,kF;AACA,uF;AACA,0E;;AAEA,gF;AACA,4E;AACA,uD;;AAEA,oC;;AAEA,+E;;AAEA,iG;AACA,0D;AACA,6B;;AAEA,kF;AACA,2C;AACA,yB;AACA,gE;AACA,qE;;AAEA,yE;AACA,qD;AACA,kC;AACA,qB;AACA,wB;;AAEA,iE;AACA,+D;AACA,8C;;AAEA,mC;AACA,8C;AACA,iB;AACA,oB;AACA,0C;AACA,a;;AAEA,2B;;AAEA,+B;AACA,uC;;AAEA,sB;AACA,0C;;AAEA,2C;AACA,0D;AACA,kE;AACA,kC;AACA,iB;AACA,uB;;AAEA,uB;AACA,a;AACA,S;;AAEA,yB;AACA,0E;;AAEA,4B;AACA,+C;;AAEA,kC;AACA,+B;AACA,qC;AACA,wC;AACA,6B;;AAEA,uB;AACA,2B;AACA,S;;AAEA,mC;AACA,qD;;AAEA,oC;AACA,4D;AACA,oC;;AAEA,kB;AACA,2B;;AAEA,+E;AACA,qF;AACA,6D;AACA,0B;;AAEA,yB;AACA,gC;;AAEA,4B;AACA,uC;;AAEA,yB;AACA,uC;;AAEA,wB;AACA,wC;AACA,oB;AACA,2B;AACA,4B;;AAEA,iC;;AAEA,6C;AACA,6F;AACA,yC;AACA,2C;;AAEA,mC;AACA,8B;AACA,6D;AACA,gG;AACA,uC;AACA,8C;AACA,wB;AACA,2B;AACA,iB;;AAEA,0C;AACA,oC;AACA,a;AACA,gB;;AAEA,oB;AACA,oC;AACA,S;AACA,e;AACA,K;;;AAGA,qC;;;AAGA,8B;AACA,gC;AACA,gC;AACA,iC;AACA,mC;AACA,qC;AACA,qC;AACA,qC;AACA,sC;;;AAGA,M;AACA,6D;AACA,M;AACA,4F;AACA,+B;AACA,8F;AACA,M;AACA,+D;AACA,6D;AACA,6E;AACA,wF;AACA,sF;AACA,iG;AACA,gE;AACA,6E;AACA,2C;AACA,2C;AACA,2C;AACA,2C;AACA,2C;AACA,2C;AACA,M;AACA,gG;AACA,M;AACA,W;AACA,+C;AACA,mE;AACA,M;AACA,6D;AACA,2D;AACA,O;AACA,uC;AACA,iB;AACA,kB;AACA,mB;AACA,0B;AACA,qB;AACA,yB;AACA,8C;AACA,wF;AACA,c;AACA,2C;AACA,oF;AACA,gF;;AAEA,iE;AACA,4C;;AAEA,yC;AACA,uC;AACA,oB;;AAEA,gE;AACA,8D;AACA,6C;AACA,a;AACA,S;AACA,8B;;AAEA,8D;AACA,2C;;AAEA,uC;AACA,sC;AACA,oB;;AAEA,+D;AACA,6D;AACA,6C;AACA,a;AACA,S;AACA,6B;;AAEA,6C;AACA,iG;AACA,4C;;AAEA,4C;AACA,qE;AACA,mG;AACA,oC;AACA,oC;AACA,oB;;AAEA,0F;AACA,yF;AACA,gD;AACA,a;AACA,S;AACA,0C;;AAEA,gF;AACA,wE;AACA,mC;;AAEA,mD;AACA,+D;AACA,oG;AACA,iC;AACA,iC;AACA,oB;;AAEA,yF;AACA,gF;AACA,mD;AACA,a;AACA,S;AACA,oC;;AAEA,yD;AACA,oC;;AAEA,oD;AACA,oC;AACA,iE;AACA,oB;;AAEA,uE;AACA,sD;AACA,a;AACA,S;AACA,sB;;AAEA,4B;AACA,oC;;AAEA,yC;AACA,2B;AACA,gC;;AAEA,uD;AACA,wE;AACA,8C;AACA,wB;AACA,a;AACA,S;AACA,sB;;AAEA,iB;AACA,M;;;AAGA,wB;;;AAGA,M;AACA,8F;AACA,uC;AACA,O;AACA,oC;AACA,kB;AACA,yB;;AAEA,kC;AACA,mC;;AAEA,kF;AACA,gD;;AAEA,oB;AACA,uD;;AAEA,wB;AACA,qC;;AAEA,qB;AACA,mC;;AAEA,oB;AACA,sC;AACA,gB;AACA,wB;AACA,wB;AACA,S;;AAEA,kB;AACA,K;;;AAGA,M;AACA,mE;AACA,O;AACA,qC;AACA,iB;AACA,kB;AACA,yB;AACA,0B;;AAEA,0B;AACA,4B;AACA,oC;AACA,uC;AACA,mB;AACA,S;;AAEA,c;AACA,wD;;AAEA,wC;AACA,K;;;AAGA,M;AACA,kE;AACA,uD;AACA,uD;AACA,O;AACA,gD;AACA,c;AACA,sB;AACA,iB;AACA,kB;AACA,8B;;AAEA,6B;AACA,mE;AACA,gE;;AAEA,2C;;AAEA,6C;AACA,6D;AACA,uD;AACA,sC;AACA,iB;AACA,a;AACA,S;;AAEA,6B;AACA,K;;AAEA,M;AACA,yE;AACA,O;AACA,wD;AACA,iC;AACA,mC;AACA,+B;;AAEA,mD;;AAEA,uB;AACA,uB;AACA,yC;AACA,sC;AACA,2C;;AAEA,kG;AACA,iG;AACA,2D;AACA,mC;AACA,S;;AAEA,yC;AACA,+C;AACA,0B;;AAEA,iC;AACA,yC;AACA,iC;;AAEA,sB;AACA,gB;AACA,gB;AACA,wB;AACA,uB;AACA,mD;AACA,0B;AACA,yD;AACA,wB;AACA,uB;AACA,uB;AACA,S;AACA,mC;;AAEA,qF;AACA,kB;AACA,wB;AACA,4C;;AAEA,kB;AACA,6E;AACA,8B;AACA,yF;;AAEA,gC;AACA,0B;AACA,kB;;AAEA,oB;;AAEA,mD;AACA,0B;AACA,oC;AACA,oB;;AAEA,wB;AACA,8B;AACA,a;AACA,gB;AACA,0B;;AAEA,oB;;AAEA,0F;AACA,yD;AACA,8B;;AAEA,+B;AACA,4B;AACA,sC;AACA,qB;AACA,iB;AACA,a;;AAEA,wC;AACA,6C;AACA,S;;AAEA,wC;AACA,yE;;AAEA,6B;AACA,sB;;AAEA,6B;AACA,2C;AACA,6B;;AAEA,6B;AACA,gB;AACA,2B;;AAEA,4B;AACA,4B;AACA,iD;AACA,iC;AACA,6D;AACA,a;AACA,S;;AAEA,6D;AACA,mB;AACA,K;;;AAGA,M;AACA,6E;AACA,O;AACA,6B;;AAEA,oC;AACA,yC;AACA,kC;AACA,0B;AACA,6B;AACA,oC;AACA,wC;;AAEA,yC;AACA,uC;AACA,2C;AACA,0C;AACA,6E;AACA,gF;AACA,mC;AACA,a;AACA,wC;;AAEA,qB;AACA,S;;AAEA,0C;AACA,uB;;AAEA,6B;AACA,uC;AACA,oB;;AAEA,kD;;AAEA,yC;AACA,mD;AACA,8B;AACA,qB;AACA,iB;AACA,a;AACA,uB;AACA,S;;AAEA,6C;AACA,sB;;AAEA,iC;AACA,6B;AACA,2B;AACA,0C;AACA,iD;AACA,a;;AAEA,oC;AACA,uD;AACA,S;;AAEA,mC;AACA,gD;AACA,qF;AACA,uB;AACA,8C;AACA,4B;AACA,4B;;AAEA,yC;AACA,mD;;AAEA,qC;;AAEA,qE;AACA,mF;;AAEA,+F;AACA,2D;AACA,kB;AACA,a;;AAEA,iC;AACA,6B;AACA,gC;AACA,2B;;AAEA,0B;AACA,4B;;AAEA,sF;AACA,4F;AACA,2F;;AAEA,qC;AACA,a;;AAEA,2E;AACA,2F;AACA,wD;AACA,8C;;AAEA,0B;AACA,2B;AACA,4B;AACA,oB;AACA,+B;AACA,+B;AACA,sB;AACA,uB;;AAEA,kB;AACA,+D;AACA,gC;AACA,0B;AACA,+B;AACA,wB;AACA,sC;AACA,2D;AACA,iE;AACA,0D;AACA,oD;AACA,mC;AACA,qB;AACA,uC;;AAEA,kC;AACA,wB;AACA,kB;AACA,oF;;AAEA,0D;;AAEA,kC;AACA,qD;AACA,qD;AACA,uC;AACA,uC;AACA,qB;;AAEA,4B;AACA,4C;AACA,sC;;AAEA,sE;AACA,yD;AACA,oC;AACA,kC;AACA,gC;AACA,mD;;AAEA,wB;AACA,8B;;AAEA,yD;AACA,2D;;AAEA,kD;AACA,wC;;AAEA,wD;;AAEA,0C;AACA,mF;;AAEA,+F;AACA,wD;;;AAGA,0C;AACA,sE;AACA,kF;AACA,uD;AACA,mE;AACA,sE;AACA,sF;;AAEA,0C;AACA,8D;;AAEA,mE;AACA,+D;AACA,oD;AACA,kD;;AAEA,iE;AACA,wE;;AAEA,uD;AACA,iD;AACA,wC;;AAEA,qE;AACA,wF;AACA,iC;AACA,oC;;AAEA,6C;AACA,iG;AACA,kE;AACA,6E;AACA,0D;AACA,kD;AACA,6B;;AAEA,gD;AACA,gE;;AAEA,+D;AACA,8D;;AAEA,mE;AACA,8C;AACA,kD;;AAEA,qE;AACA,mE;;AAEA,+F;AACA,gD;AACA,wC;;AAEA,uE;AACA,qF;AACA,iC;AACA,6B;AACA,8C;AACA,iD;AACA,gC;AACA,sC;AACA,yD;;AAEA,sE;AACA,oC;;AAEA,gD;AACA,8C;AACA,sD;AACA,gC;AACA,6C;AACA,qC;AACA,yB;AACA,uE;;AAEA,0C;AACA,mB;;AAEA,gC;AACA,yC;AACA,a;;AAEA,iC;;AAEA,6E;AACA,gE;AACA,+E;;AAEA,qD;AACA,oB;AACA,2B;AACA,+B;AACA,a;AACA,qB;AACA,U;AACA,S;;;AAGA,M;AACA,8F;AACA,qE;AACA,M;AACA,mG;AACA,8F;AACA,iF;AACA,+C;AACA,O;AACA,gC;AACA,sB;AACA,8C;;AAEA,sF;AACA,0B;AACA,kB;AACA,gB;AACA,yC;;AAEA,mE;AACA,uC;AACA,uB;AACA,S;AACA,4C;;AAEA,iG;AACA,iG;AACA,8B;;AAEA,gC;AACA,kE;;AAEA,4B;AACA,iD;AACA,2E;AACA,8C;;AAEA,gC;AACA,gB;AACA,2B;;AAEA,iC;AACA,0B;AACA,0B;;AAEA,iC;AACA,+C;AACA,iC;;AAEA,iC;AACA,oB;;AAEA,gC;AACA,8B;;AAEA,oC;AACA,qD;AACA,4C;AACA,wB;AACA,8B;;AAEA,kC;AACA,qE;AACA,yC;AACA,mC;AACA,qB;AACA,iB;AACA,a;;AAEA,iC;AACA,mD;AACA,S;AACA,yD;AACA,K;;;AAGA,uD;AACA,wE;;AAEA,qB;AACA,sB;AACA,iF;AACA,qF;AACA,4E;AACA,mE;AACA,+D;;AAEA,yB;AACA,4E;AACA,wD;AACA,2C;AACA,gD;AACA,4C;AACA,sD;AACA,yC;AACA,kD;AACA,+C;AACA,sD;AACA,8C;;AAEA,gC;AACA,uC;AACA,8C;AACA,wB;AACA,S;AACA,K;;;AAGA,M;AACA,0F;AACA,O;AACA,kC;AACA,sC;AACA,8B;;AAEA,yC;AACA,4B;;AAEA,4F;AACA,yF;AACA,4C;AACA,2C;AACA,+F;AACA,4C;AACA,wF;AACA,kB;;AAEA,uE;AACA,gE;AACA,2B;;AAEA,yE;AACA,8B;AACA,kC;AACA,2B;AACA,qC;;AAEA,8D;AACA,0D;AACA,wB;AACA,2D;;AAEA,4C;;AAEA,gC;;AAEA,8C;AACA,kE;AACA,uC;AACA,kC;AACA,0C;AACA,iD;AACA,gC;AACA,sC;AACA,yB;AACA,4B;AACA,uC;;AAEA,yD;AACA,6D;;AAEA,wD;AACA,sC;;AAEA,oF;AACA,qF;AACA,6C;;AAEA,kE;AACA,0E;AACA,qB;AACA,iB;;AAEA,kC;;AAEA,0E;AACA,oG;AACA,+F;AACA,gF;;AAEA,0B;AACA,8E;AACA,qE;;AAEA,wF;AACA,4F;AACA,qD;;AAEA,yC;AACA,kC;;AAEA,4B;;AAEA,wD;AACA,yC;;AAEA,2D;AACA,wD;AACA,0C;AACA,4B;;AAEA,gC;AACA,2C;AACA,qB;;AAEA,6B;AACA,iB;;AAEA,wC;AACA,+B;AACA,mC;AACA,0B;AACA,yB;AACA,wB;AACA,uC;AACA,+C;;AAEA,2E;AACA,oE;AACA,0F;AACA,iB;;AAEA,4B;AACA,wB;;AAEA,iC;;AAEA,yF;AACA,wC;;AAEA,+E;AACA,4E;AACA,2C;AACA,iE;;AAEA,kE;AACA,2C;AACA,yC;AACA,+D;AACA,6B;AACA,kC;AACA,gC;AACA,wC;AACA,wD;AACA,yC;AACA,kC;AACA,yB;AACA,qB;AACA,iB;;AAEA,yC;AACA,+D;AACA,a;;AAEA,kC;AACA,qC;AACA,uC;;AAEA,+B;AACA,4C;AACA,wC;AACA,a;AACA,S;;AAEA,iB;AACA,K;;;AAGA,iC;;;AAGA,M;AACA,kF;AACA,O;AACA,iD;AACA,oC;AACA,qC;AACA,iB;AACA,M;;;AAGA,M;AACA,kG;AACA,oC;AACA,O;AACA,6B;AACA,4D;AACA,M;;;AAGA,M;AACA,a;AACA,qF;AACA,mF;AACA,qC;AACA,6C;AACA,O;AACA,oD;AACA,c;AACA,qB;AACA,wB;AACA,8D;AACA,uB;AACA,uB;AACA,uB;AACA,uB;;AAEA,sB;AACA,oC;;AAEA,yB;AACA,yB;;AAEA,uB;AACA,gD;;AAEA,wB;AACA,+B;;AAEA,kB;AACA,mB;;AAEA,2B;AACA,0D;;AAEA,6B;AACA,4C;AACA,e;AACA,0D;;AAEA,kC;AACA,mF;;AAEA,2B;AACA,+C;AACA,M;;;AAGA,M;AACA,kG;AACA,2C;AACA,O;AACA,gD;AACA,iB;AACA,0B;;AAEA,8B;AACA,oF;;AAEA,oE;AACA,4D;AACA,2B;;AAEA,iB;AACA,M;;;AAGA,M;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,M;AACA,gG;AACA,8E;AACA,O;AACA,mD;AACA,e;AACA,iF;AACA,M;;;AAGA,M;AACA,2F;AACA,iD;AACA,O;AACA,iE;AACA,gB;AACA,wD;AACA,M;;;AAGA,M;AACA,2F;AACA,+B;AACA,O;AACA,+C;AACA,e;AACA,yC;AACA,M;;;AAGA,M;AACA,kG;AACA,qC;AACA,O;AACA,8B;AACA,4D;AACA,M;;;AAGA,M;AACA,+F;AACA,+B;AACA,O;AACA,oD;AACA,e;AACA,uC;AACA,M;;;AAGA,M;AACA,0F;AACA,gD;AACA,O;AACA,8D;AACA,e;AACA,2D;AACA,M;;;AAGA,M;AACA,8F;AACA,O;AACA,iC;AACA,2B;AACA,M;;;AAGA,M;AACA,wF;AACA,O;AACA,+C;AACA,uF;AACA,M;;;AAGA,M;AACA,kF;AACA,O;AACA,8B;AACA,0B;AACA,M;;;AAGA,M;AACA,uF;AACA,O;AACA,gD;AACA,6B;AACA,M;;;AAGA,M;AACA,sF;AACA,O;AACA,+B;AACA,gD;AACA,M;;;AAGA,M;AACA,4F;AACA,+B;AACA,O;AACA,iD;AACA,e;AACA,uC;AACA,M;;;AAGA,M;AACA,uF;AACA,gD;AACA,O;AACA,2D;AACA,e;AACA,4D;AACA,M;;;AAGA,M;AACA,iB;AACA,iB;AACA,kB;AACA,kB;AACA,iB;AACA,iB;AACA,kB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,M;AACA,2F;AACA,uB;AACA,O;AACA,oC;AACA,0B;AACA,qB;AACA,uB;;AAEA,e;AACA,kC;AACA,mB;;AAEA,sB;AACA,kD;;AAEA,wB;AACA,uB;AACA,wB;AACA,gC;AACA,S;;AAEA,mC;AACA,mC;AACA,wB;AACA,wB;;AAEA,2B;;AAEA,+B;AACA,6F;;AAEA,2B;AACA,qC;;AAEA,2F;AACA,8E;;AAEA,+E;AACA,gD;AACA,a;AACA,S;;AAEA,0B;AACA,mB;AACA,4C;AACA,mB;AACA,4C;AACA,wB;;AAEA,gD;AACA,4B;;AAEA,iC;AACA,+B;AACA,oB;AACA,gC;AACA,a;;AAEA,mD;AACA,uD;AACA,wB;AACA,gB;;AAEA,qD;AACA,yE;;AAEA,2C;;AAEA,uC;AACA,yC;AACA,0B;AACA,iB;AACA,a;AACA,S;;AAEA,6D;AACA,4D;;AAEA,kD;;AAEA,yC;AACA,iG;AACA,gD;AACA,qB;;AAEA,+B;AACA,0B;;AAEA,oC;AACA,wD;AACA,wB;AACA,8B;AACA,a;AACA,2B;AACA,S;;AAEA,gE;AACA,+C;;AAEA,gB;AACA,uB;;AAEA,6C;AACA,4E;AACA,iD;AACA,oC;AACA,qB;AACA,S;;AAEA,mG;AACA,+B;AACA,sC;AACA,M;;;AAGA,M;AACA,mB;AACA,mB;AACA,mB;AACA,mB;AACA,mB;AACA,mB;AACA,mB;AACA,mB;AACA,mB;AACA,M;AACA,4F;AACA,uB;AACA,O;AACA,gD;AACA,e;AACA,qB;AACA,wB;AACA,oD;AACA,wB;AACA,wB;;AAEA,sC;AACA,uC;AACA,qE;;AAEA,4B;AACA,6B;AACA,oB;AACA,oB;;AAEA,kF;AACA,M;;;AAGA,M;AACA,iG;AACA,a;AACA,O;AACA,2C;AACA,oC;AACA,iC;AACA,iB;AACA,M;;;AAGA,M;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,M;AACA,0F;AACA,uB;AACA,O;AACA,mC;AACA,c;AACA,qB;AACA,uB;;AAEA,gB;AACA,kC;AACA,mB;;AAEA,sB;AACA,kD;;AAEA,wB;AACA,wB;AACA,wB;AACA,iC;AACA,S;;AAEA,mC;AACA,mC;AACA,wB;AACA,wB;;AAEA,2B;;AAEA,oD;AACA,4D;;AAEA,oG;AACA,0F;AACA,S;;AAEA,2B;AACA,mB;AACA,4C;AACA,mB;AACA,4C;AACA,wB;;AAEA,uF;AACA,4B;AACA,0B;AACA,gC;AACA,oB;AACA,+B;AACA,a;;AAEA,gD;AACA,wB;AACA,S;AACA,sB;AACA,sB;;AAEA,qE;AACA,wD;;AAEA,kG;AACA,2B;AACA,2D;AACA,0B;AACA,S;;;AAGA,gB;AACA,0B;AACA,iB;AACA,S;;AAEA,qE;AACA,oC;AACA,sC;AACA,M;;;AAGA,M;AACA,mG;AACA,gG;AACA,M;AACA,iD;AACA,+C;AACA,O;AACA,sC;;AAEA,0F;;AAEA,wD;AACA,0D;AACA,6E;;AAEA,kF;AACA,oG;;AAEA,gD;AACA,8C;AACA,+E;;AAEA,kE;AACA,M;;;AAGA,M;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,M;AACA,4F;AACA,6D;AACA,O;AACA,+C;AACA,4B;AACA,qB;AACA,uB;AACA,uB;AACA,uB;AACA,oC;AACA,wC;;AAEA,sC;AACA,uC;AACA,wF;AACA,S;;AAEA,4B;AACA,4B;;AAEA,wC;AACA,kF;AACA,qC;AACA,uC;AACA,sD;AACA,6B;AACA,gE;;AAEA,+B;AACA,6B;AACA,oB;AACA,sC;AACA,yD;AACA,a;AACA,iC;AACA,gB;AACA,8C;AACA,S;;AAEA,kG;AACA,gG;AACA,wC;AACA,0B;AACA,uB;AACA,uB;AACA,+B;;AAEA,wC;AACA,yB;AACA,sB;AACA,qE;;AAEA,4E;AACA,sE;;AAEA,6F;AACA,kG;AACA,yC;AACA,0C;AACA,gD;;AAEA,mG;AACA,kG;AACA,+D;;AAEA,mG;AACA,qE;AACA,qC;AACA,qE;;AAEA,2D;AACA,sC;AACA,sC;AACA,6B;AACA,yB;AACA,gC;AACA,+B;AACA,gC;AACA,4B;;AAEA,kG;AACA,sF;AACA,0E;;AAEA,oE;AACA,qE;AACA,wD;AACA,yB;AACA,8B;AACA,qB;AACA,iB;AACA,a;AACA,S;;AAEA,uE;AACA,M;;;AAGA,M;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,iB;AACA,M;AACA,2F;AACA,uB;AACA,O;AACA,oC;AACA,8C;AACA,qB;AACA,wB;AACA,6D;AACA,kC;AACA,kC;AACA,uB;;AAEA,8C;;AAEA,iC;AACA,mE;;AAEA,kG;AACA,8F;;AAEA,oF;AACA,uD;AACA,S;;AAEA,2C;AACA,wD;AACA,uD;;AAEA,sB;AACA,sB;;AAEA,mE;AACA,kE;;AAEA,kD;AACA,kD;;AAEA,oB;AACA,kC;AACA,kB;AACA,sB;AACA,kB;AACA,oC;AACA,wC;;AAEA,8B;AACA,0C;AACA,4C;AACA,0C;AACA,+E;AACA,2E;AACA,oC;AACA,a;AACA,qB;AACA,S;;AAEA,gB;AACA,gB;AACA,gB;AACA,sB;AACA,S;;AAEA,oC;AACA,M;;;AAGA,M;AACA,mG;AACA,mE;AACA,M;AACA,iD;AACA,O;AACA,wC;AACA,qB;;AAEA,yF;;AAEA,oF;AACA,kE;AACA,0C;;AAEA,oE;AACA,kE;AACA,uE;AACA,kD;AACA,M;;;AAGA,M;AACA,8F;AACA,mE;AACA,M;AACA,sE;AACA,8C;AACA,M;AACA,iD;AACA,O;AACA,kC;AACA,gB;AACA,qB;AACA,6B;AACA,6B;;AAEA,mE;;AAEA,4D;AACA,0D;AACA,gG;AACA,yC;;AAEA,6C;;AAEA,sC;AACA,+B;AACA,gB;AACA,kC;;AAEA,mE;AACA,0E;AACA,yC;;AAEA,6F;AACA,mC;AACA,iD;;AAEA,4F;AACA,oD;AACA,oC;AACA,iB;AACA,a;AACA,S;;AAEA,yB;AACA,yB;;AAEA,mB;AACA,M;;;AAGA,M;AACA,+F;AACA,iG;AACA,4C;AACA,M;AACA,iB;AACA,mC;AACA,iC;AACA,0B;AACA,mC;AACA,qE;AACA,iC;AACA,S;AACA,M;AACA,iE;AACA,4F;AACA,O;AACA,mC;AACA,qB;;AAEA,2C;;AAEA,c;AACA,+B;AACA,sD;AACA,sC;AACA,+C;AACA,2C;AACA,6B;AACA,kC;AACA,2D;AACA,mC;;AAEA,kD;;AAEA,kC;AACA,+B;AACA,+C;AACA,6F;AACA,yE;AACA,+C;AACA,S;;AAEA,2B;AACA,0F;AACA,4E;AACA,uD;AACA,4B;AACA,oB;AACA,M;;;AAGA,M;AACA,kG;AACA,gG;AACA,iG;AACA,gG;AACA,e;AACA,M;AACA,oE;AACA,O;AACA,uC;AACA,6C;AACA,yC;AACA,yC;AACA,qB;AACA,wB;AACA,mC;;AAEA,yB;AACA,uC;AACA,oC;;AAEA,+B;AACA,2C;AACA,kF;;AAEA,6D;AACA,4E;;AAEA,gD;AACA,8D;;AAEA,wC;AACA,sF;;AAEA,2E;AACA,yE;AACA,iF;;AAEA,kG;AACA,mD;;AAEA,2D;AACA,kC;AACA,S;;AAEA,sB;AACA,wB;AACA,6B;;AAEA,sB;AACA,uB;;AAEA,sB;AACA,kC;AACA,8C;AACA,8C;AACA,oB;AACA,oB;AACA,qD;AACA,oB;AACA,mD;AACA,mB;AACA,S;;AAEA,gD;AACA,2C;AACA,2C;AACA,mC;AACA,e;;AAEA,kE;AACA,0E;AACA,wE;AACA,kD;AACA,mD;;AAEA,sB;;AAEA,mB;AACA,M;;;AAGA,M;AACA,0E;AACA,O;AACA,iC;AACA,qB;;AAEA,wC;AACA,mD;AACA,M;;;AAGA,M;AACA,2F;AACA,4E;AACA,M;AACA,6D;AACA,O;AACA,4C;;AAEA,6D;AACA,qC;AACA,oC;AACA,mC;;AAEA,sD;AACA,yF;;AAEA,6D;AACA,0F;AACA,gF;AACA,uD;;AAEA,qD;AACA,mD;AACA,4E;AACA,kE;;AAEA,yC;AACA,sD;AACA,S;AACA,2B;;AAEA,qB;AACA,2C;AACA,oB;AACA,4B;AACA,8B;AACA,S;;AAEA,yC;AACA,M;;;AAGA,M;AACA,oG;AACA,6F;AACA,iG;AACA,M;AACA,+C;AACA,O;AACA,sC;AACA,qB;;AAEA,gF;AACA,oE;AACA,kC;AACA,4F;;AAEA,2D;AACA,yD;AACA,2E;AACA,sD;AACA,M;;;AAGA,M;AACA,6F;AACA,gG;AACA,oG;AACA,oG;AACA,mC;AACA,M;AACA,+C;AACA,O;AACA,kC;AACA,yB;AACA,qB;AACA,wB;;AAEA,2B;AACA,4B;AACA,8C;;AAEA,8B;AACA,0E;AACA,qC;AACA,gB;AACA,gD;;AAEA,iC;AACA,2B;;AAEA,iC;AACA,gD;AACA,iC;;AAEA,iC;AACA,qD;;AAEA,gC;AACA,oC;AACA,0D;AACA,yC;AACA,mE;AACA,iB;;AAEA,6B;AACA,oB;AACA,kC;;AAEA,iC;AACA,iD;;AAEA,6B;AACA,wC;AACA,6B;AACA,iB;AACA,a;;AAEA,8B;;AAEA,2F;AACA,gE;;AAEA,iC;AACA,iD;AACA,wB;;AAEA,4D;AACA,0D;AACA,0D;AACA,iB;AACA,a;;AAEA,S;;AAEA,4C;AACA,M;;;AAGA,M;AACA,6D;AACA,O;AACA,8C;AACA,+B;AACA,M;;;AAGA,0C;AACA,2B;AACA,iC;AACA,iC;AACA,6B;AACA,gC;AACA,gC;AACA,6B;;;AAGA,a;;;AAGA,6E;AACA,qB;AACA,K","file":"/packages/3stack:bignumber.js","sourcesContent":["/*! bignumber.js v2.0.0 https://github.com/MikeMcl/bignumber.js/LICENCE */\n\nBigNumber = (function () {\n    'use strict';\n\n    /*\n      bignumber.js v2.0.0\n      A JavaScript library for arbitrary-precision arithmetic.\n      https://github.com/MikeMcl/bignumber.js\n      Copyright (c) 2014 Michael Mclaughlin <M8ch88l@gmail.com>\n      MIT Expat Licence\n    */\n\n    /*********************************** DEFAULTS ************************************/\n\n    /*\n     * The default values below must be integers within the inclusive ranges stated.\n     * Most of these values can be changed at run-time using the BigNumber.config method.\n     */\n\n    /*\n     * The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP,\n     * MAX_EXP, and the argument to toExponential, toFixed, toFormat, and toPrecision,\n     * beyond which an exception is thrown (if ERRORS is true).\n     */\n    var MAX = 1E9,                                   // 0 to 1e+9\n\n        // Limit of magnitude of exponent argument to toPower.\n        MAX_POWER = 1E6,                             // 1 to 1e+6\n\n        // The maximum number of decimal places for operations involving division.\n        DECIMAL_PLACES = 20,                         // 0 to MAX\n\n        /*\n         * The rounding mode used when rounding to the above decimal places, and when using\n         * toExponential, toFixed, toFormat and toPrecision, and round (default value).\n         * UP         0 Away from zero.\n         * DOWN       1 Towards zero.\n         * CEIL       2 Towards +Infinity.\n         * FLOOR      3 Towards -Infinity.\n         * HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n         * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n         * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n         * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n         * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n         */\n        ROUNDING_MODE = 4,                           // 0 to 8\n\n        // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\n\n        // The exponent value at and beneath which toString returns exponential notation.\n        // Number type: -7\n        TO_EXP_NEG = -7,                             // 0 to -MAX\n\n        // The exponent value at and above which toString returns exponential notation.\n        // Number type: 21\n        TO_EXP_POS = 21,                             // 0 to MAX\n\n        // RANGE : [MIN_EXP, MAX_EXP]\n\n        // The minimum exponent value, beneath which underflow to zero occurs.\n        // Number type: -324  (5e-324)\n        MIN_EXP = -MAX,                              // -1 to -MAX\n\n        // The maximum exponent value, above which overflow to Infinity occurs.\n        // Number type:  308  (1.7976931348623157e+308)\n        MAX_EXP = MAX,                               // 1 to MAX\n\n        // Whether BigNumber Errors are ever thrown.\n        // CHANGE parseInt to parseFloat if changing ERRORS to false.\n        ERRORS = true,                               // true or false\n        parse = parseInt,                            // parseInt or parseFloat\n\n        // Format specification for the BigNumber.prototype.toFormat method.\n        FORMAT = {\n            decimalSeparator: '.',\n            groupSeparator: ',',\n            groupSize: 3,\n            secondaryGroupSize: 0,\n            fractionGroupSeparator: '\\xA0',              // non-breaking space\n            fractionGroupSize: 0\n        },\n\n    /***********************************************************************************/\n\n        P = BigNumber.prototype,\n        DIGITS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',\n        outOfRange,\n        id = 0,\n        mathfloor = Math.floor,\n        isValid = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\n        trim = String.prototype.trim || function () {return this.replace(/^\\s+|\\s+$/g, '')},\n        BASE = 1e14,\n        LOG_BASE = 14,\n        SQRT_BASE = 1e7,\n        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\n        ONE = new BigNumber(1);\n\n\n    // CONSTRUCTOR\n\n\n    /*\n     * The exported function.\n     * Create and return a new instance of a BigNumber object.\n     *\n     * v {number|string|BigNumber} A numeric value.\n     * [b] {number} The base of v. Integer, 2 to 64 inclusive.\n     */\n    function BigNumber( n, b ) {\n        var d, e, i, isNum, str, valid,\n            x = this;\n\n        // Enable constructor usage without new.\n        if ( !( x instanceof BigNumber ) ) return new BigNumber( n, b );\n\n        // Duplicate.\n        if ( n instanceof BigNumber ) {\n\n            if ( b == null ) {\n                id = 0;\n                x['s'] = n['s'];\n                x['e'] = n['e'];\n                x['c'] = ( n = n['c'] ) ? n.slice() : n;\n                return;\n            }\n            n += '';\n        } else if ( isNum = ( str = typeof n ) == 'number' ) {\n\n            // Fast path for integers.\n            if ( b == null && n === ~~n ) {\n                x['s'] = 1 / n < 0 ? ( n = -n, -1 ) : 1;\n                for ( e = id = 0, i = n; i >= 10; i /= 10, e++ );\n                x['e'] = e;\n                x['c'] = [n];\n                return;\n            }\n\n            // Minus zero?\n            n = n === 0 && 1 / n < 0 ? '-0' : n + '';\n        } else if ( str != 'string' ) {\n            n += '';\n        }\n        str = n;\n\n        if ( b == null && isValid.test(str) ) {\n\n            // Determine sign.\n            x['s'] = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;\n\n        // Either str is not a valid BigNumber or a base has been specified.\n        } else {\n\n            // Enable exponential notation to be used with base 10 argument.\n            // Ensure return value is rounded to DECIMAL_PLACES as with other bases.\n            if ( b == 10 ) {\n                x = new BigNumber(str);\n                return rnd( x, DECIMAL_PLACES + x['e'] + 1, ROUNDING_MODE );\n            }\n            str = trim.call(str).replace( /^\\+(?!-)/, '' );\n            x['s'] = str.charCodeAt(0) === 45 ? ( str = str.replace( /^-(?!-)/, '' ), -1 ) : 1;\n\n            if ( b != null ) {\n\n                if ( ( b == ~~b || !ERRORS ) && !( outOfRange = !( b >= 2 && b < 65 ) ) ) {\n                    d = '[' + DIGITS.slice( 0, b = b | 0 ) + ']+';\n\n                    // Before non-decimal number validity test and base conversion\n                    // remove the `.` from e.g. '1.', and replace e.g. '.1' with '0.1'.\n                    str = str.replace( /\\.$/, '' ).replace( /^\\./, '0.' );\n\n                    // Any number in exponential form will fail due to the e+/-.\n                    if ( valid = new RegExp( '^' + d + '(?:\\\\.' + d + ')?$',\n                      b < 37 ? 'i' : '' ).test(str) ) {\n\n                        if (isNum) {\n\n                            if ( str.replace( /^0\\.0*|\\./, '' ).length > 15 ) {\n\n                        // 'new BigNumber() number type has more than 15 significant digits: {n}'\n                                ifExceptionsThrow( n, 0 );\n                            }\n\n                            // Prevent later check for length on converted number.\n                            isNum = !isNum;\n                        }\n                        str = convertBase( str, 10, b, x['s'] );\n                    } else if ( str != 'Infinity' && str != 'NaN' ) {\n\n                        // 'new BigNumber() not a base {b} number: {str}'\n                        ifExceptionsThrow( n, 1, b );\n                        n = 'NaN';\n                    }\n                } else {\n\n                    // 'new BigNumber() base not an integer: {b}'\n                    // 'new BigNumber() base out of range: {b}'\n                    ifExceptionsThrow( b, 2 );\n\n                    // Ignore base.\n                    valid = isValid.test(str);\n                }\n            } else {\n                valid = isValid.test(str);\n            }\n\n            if ( !valid ) {\n\n                // Infinity/NaN\n                x['c'] = x['e'] = null;\n\n                // NaN\n                if ( str != 'Infinity' ) {\n\n                    // No exception on NaN.\n                    // 'new BigNumber() not a number: {n}'\n                    if ( str != 'NaN' ) ifExceptionsThrow( n, 3 );\n                    x['s'] = null;\n                }\n                id = 0;\n\n                return;\n            }\n        }\n\n        // Decimal point?\n        if ( ( e = str.indexOf('.') ) > -1 ) str = str.replace( '.', '' );\n\n        // Exponential form?\n        if ( ( i = str.search( /e/i ) ) > 0 ) {\n\n            // Determine exponent.\n            if ( e < 0 ) e = i;\n            e += +str.slice( i + 1 );\n            str = str.substring( 0, i );\n        } else if ( e < 0 ) {\n\n            // Integer.\n            e = str.length;\n        }\n\n        // Determine leading zeros.\n        for ( i = 0; str.charCodeAt(i) === 48; i++ );\n\n        // Determine trailing zeros.\n        for ( b = str.length; str.charCodeAt(--b) === 48; );\n        str = str.slice( i, b + 1 );\n\n        if (str) {\n            b = str.length;\n\n            // Disallow numbers with over 15 significant digits if number type.\n            // 'new BigNumber() number type has more than 15 significant digits: {n}'\n            if ( isNum && b > 15 ) ifExceptionsThrow( n, 0 );\n            e = e - i - 1;\n\n             // Overflow?\n            if ( e > MAX_EXP ) {\n\n                // Infinity.\n                x['c'] = x['e'] = null;\n\n            // Underflow?\n            } else if ( e < MIN_EXP ) {\n\n                // Zero.\n                x['c'] = [ x['e'] = 0 ];\n            } else {\n                x['e'] = e;\n                x['c'] = [];\n\n                // Transform base\n\n                // e is the base 10 exponent.\n                // i is where to slice str to get the first element of the coefficient array.\n                i = ( e + 1 ) % LOG_BASE;\n                if ( e < 0 ) i += LOG_BASE;\n\n                // b is str.length.\n                if ( i < b ) {\n                    if (i) x['c'].push( +str.slice( 0, i ) );\n                    for ( b -= LOG_BASE; i < b; x['c'].push( +str.slice( i, i += LOG_BASE ) ) );\n                    str = str.slice(i);\n                    i = LOG_BASE - str.length;\n                } else {\n                    i -= b;\n                }\n\n                for ( ; i--; str += '0' );\n                x['c'].push( +str );\n            }\n        } else {\n\n            // Zero.\n            x['c'] = [ x['e'] = 0 ];\n        }\n        id = 0;\n    }\n\n\n    // CONSTRUCTOR PROPERTIES/METHODS\n\n\n    BigNumber['ROUND_UP'] = 0;\n    BigNumber['ROUND_DOWN'] = 1;\n    BigNumber['ROUND_CEIL'] = 2;\n    BigNumber['ROUND_FLOOR'] = 3;\n    BigNumber['ROUND_HALF_UP'] = 4;\n    BigNumber['ROUND_HALF_DOWN'] = 5;\n    BigNumber['ROUND_HALF_EVEN'] = 6;\n    BigNumber['ROUND_HALF_CEIL'] = 7;\n    BigNumber['ROUND_HALF_FLOOR'] = 8;\n\n\n    /*\n     * Configure infrequently-changing library-wide settings.\n     *\n     * Accept an object or an argument list, with one or many of the following properties or\n     * parameters respectively:\n     * [ DECIMAL_PLACES [, ROUNDING_MODE [, EXPONENTIAL_AT [, RANGE [, ERRORS [, FORMAT ]]]]]]\n     *\n     *   DECIMAL_PLACES  {number}  Integer, 0 to MAX inclusive.\n     *   ROUNDING_MODE   {number}  Integer, 0 to 8 inclusive.\n     *   EXPONENTIAL_AT  {number|number[]}  Integer, -MAX to MAX inclusive or\n     *                                      [ integer -MAX to 0 incl., 0 to MAX incl. ].\n     *   RANGE           {number|number[]}  Non-zero integer, -MAX to MAX inclusive or\n     *                                      [ integer -MAX to -1 incl., integer 1 to MAX incl. ].\n     *   ERRORS          {boolean|number}   true, false, 1 or 0.\n     *   FORMAT          {object}           See BigNumber.prototype.toFormat.\n     *      decimalSeparator       {string}\n     *      groupSeparator         {string}\n     *      groupSize              {number}\n     *      secondaryGroupSize     {number}\n     *      fractionGroupSeparator {string}\n     *      fractionGroupSize      {number}\n     *\n     * The validity of the values assigned to the above FORMAT object properties is not checked.\n     *\n     * E.g.\n     * BigNumber.config(20, 4) is equivalent to\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\n     *\n     * Ignore properties/parameters set to null or undefined.\n     * Return an object with the properties current values.\n     */\n    BigNumber['config'] = function () {\n        var v, p,\n            i = 0,\n            r = {},\n            a = arguments,\n            o = a[0],\n            c = 'config',\n            inRange = function ( n, lo, hi ) {\n              return !( ( outOfRange = n < lo || n > hi ) || parse(n) != n && n !== 0 );\n            },\n            has = o && typeof o == 'object'\n              ? function () {if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null}\n              : function () {if ( a.length > i ) return ( v = a[i++] ) != null};\n\n        // [DECIMAL_PLACES] {number} Integer, 0 to MAX inclusive.\n        if ( has( p = 'DECIMAL_PLACES' ) ) {\n\n            if ( inRange( v, 0, MAX ) ) {\n                DECIMAL_PLACES = v | 0;\n            } else {\n\n                // 'config() DECIMAL_PLACES not an integer: {v}'\n                // 'config() DECIMAL_PLACES out of range: {v}'\n                ifExceptionsThrow( v, p, c );\n            }\n        }\n        r[p] = DECIMAL_PLACES;\n\n        // [ROUNDING_MODE] {number} Integer, 0 to 8 inclusive.\n        if ( has( p = 'ROUNDING_MODE' ) ) {\n\n            if ( inRange( v, 0, 8 ) ) {\n                ROUNDING_MODE = v | 0;\n            } else {\n\n                // 'config() ROUNDING_MODE not an integer: {v}'\n                // 'config() ROUNDING_MODE out of range: {v}'\n                ifExceptionsThrow( v, p, c );\n            }\n        }\n        r[p] = ROUNDING_MODE;\n\n        // [EXPONENTIAL_AT] {number|number[]}\n        // Integer, -MAX to MAX inclusive or [ integer -MAX to 0 inclusive, 0 to MAX inclusive ].\n        if ( has( p = 'EXPONENTIAL_AT' ) ) {\n\n            if ( inRange( v, -MAX, MAX ) ) {\n                TO_EXP_NEG = -( TO_EXP_POS = ~~( v < 0 ? -v : +v ) );\n            } else if ( !outOfRange && v && inRange( v[0], -MAX, 0 ) && inRange( v[1], 0, MAX ) ) {\n                TO_EXP_NEG = ~~v[0];\n                TO_EXP_POS = ~~v[1];\n            } else {\n\n                // 'config() EXPONENTIAL_AT not an integer or not [integer, integer]: {v}'\n                // 'config() EXPONENTIAL_AT out of range or not [negative, positive: {v}'\n                ifExceptionsThrow( v, p, c, 1 );\n            }\n        }\n        r[p] = [ TO_EXP_NEG, TO_EXP_POS ];\n\n        // [RANGE][ {number|number[]} Non-zero integer, -MAX to MAX inclusive or\n        // [ integer -MAX to -1 inclusive, integer 1 to MAX inclusive ].\n        if ( has( p = 'RANGE' ) ) {\n\n            if ( inRange( v, -MAX, MAX ) && ~~v ) {\n                MIN_EXP = -( MAX_EXP = ~~( v < 0 ? -v : +v ) );\n            } else if ( !outOfRange && v && inRange( v[0], -MAX, -1 ) && inRange( v[1], 1, MAX ) ) {\n                MIN_EXP = ~~v[0];\n                MAX_EXP = ~~v[1];\n            } else {\n\n                // 'config() RANGE not a non-zero integer or not [integer, integer]: {v}'\n                // 'config() RANGE out of range or not [negative, positive: {v}'\n                ifExceptionsThrow( v, p, c, 1, 1 );\n            }\n        }\n        r[p] = [ MIN_EXP, MAX_EXP ];\n\n        // [ERRORS] {boolean|number} true, false, 1 or 0.\n        if ( has( p = 'ERRORS' ) ) {\n\n            if ( v === !!v || v === 1 || v === 0 ) {\n                outOfRange = id = 0;\n                parse = ( ERRORS = !!v ) ? parseInt : parseFloat;\n            } else {\n\n                // 'config() ERRORS not a boolean or binary digit: {v}'\n                ifExceptionsThrow( v, p, c, 0, 0, 1 );\n            }\n        }\n        r[p] = ERRORS;\n\n        // [FORMAT] {object}\n        if ( has( p = 'FORMAT' ) ) {\n\n            if ( typeof v == 'object' ) {\n                FORMAT = v;\n            } else if (ERRORS) {\n\n                // 'config() FORMAT not an object: {v}'\n                r = new Error( c + '() ' + p + ' not an object: ' + v );\n                r['name'] = 'BigNumber Error';\n                throw r;\n            }\n        }\n        r[p] = FORMAT;\n\n        return r;\n    };\n\n\n    // PRIVATE FUNCTIONS\n\n\n    /*\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\n     * Called by minus, plus and times.\n     */\n    function normalise( bn, c, e ) {\n        var i = 1,\n            j = c.length;\n\n         // Remove trailing zeros.\n        for ( ; !c[--j]; c.pop() );\n\n        // Calculate the base 10 exponent. First get the number of digits of c[0].\n        for ( j = c[0]; j >= 10; j /= 10, i++ );\n\n        // Overflow?\n        if ( ( e = i + e * LOG_BASE - 1 ) > MAX_EXP ) {\n\n            // Infinity.\n            bn['c'] = bn['e'] = null;\n\n        // Underflow?\n        } else if ( e < MIN_EXP ) {\n\n            // Zero.\n            bn['c'] = [ bn['e'] = 0 ];\n        } else {\n            bn['e'] = e;\n            bn['c'] = c;\n        }\n\n        return bn;\n    }\n\n\n    /*\n     * Returns the coefficient array as a string of base 10 digits.\n     */\n    function coefficientToString(a) {\n        var s, z,\n            i = 1,\n            j = a.length,\n            r = a[0] + '';\n\n        for ( ; i < j; ) {\n            s = a[i++] + '';\n            z = LOG_BASE - s.length;\n            for ( ; z--; s = '0' + s );\n            r += s;\n        }\n\n        // '0'\n        for ( j = r.length; r.charCodeAt(--j) === 48; );\n\n        return r.slice( 0, j + 1 || 1 );\n    }\n\n\n    /*\n     * Convert string of baseIn to an array of numbers of baseOut.\n     * Eg. convertBase('255', 10, 16) returns [15, 15].\n     * Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\n     */\n    function toBaseOut( str, baseIn, baseOut ) {\n        var j,\n            arr = [0],\n            arrL,\n            i = 0,\n            strL = str.length;\n\n        for ( ; i < strL; ) {\n            for ( arrL = arr.length; arrL--; arr[arrL] *= baseIn );\n            arr[ j = 0 ] += DIGITS.indexOf( str.charAt( i++ ) );\n\n            for ( ; j < arr.length; j++ ) {\n\n                if ( arr[j] > baseOut - 1 ) {\n                    if ( arr[j + 1] == null ) arr[j + 1] = 0;\n                    arr[j + 1] += arr[j] / baseOut | 0;\n                    arr[j] %= baseOut;\n                }\n            }\n        }\n\n        return arr.reverse();\n    }\n\n    /*\n     * Convert a numeric string of baseIn to a numeric string of baseOut.\n     */\n    function convertBase( str, baseOut, baseIn, sign ) {\n        var d, e, j, r, x, xc, y,\n            i = str.indexOf( '.' ),\n            rm = ROUNDING_MODE;\n\n        if ( baseIn < 37 ) str = str.toLowerCase();\n\n        // Non-integer.\n        if ( i >= 0 ) {\n            str = str.replace( '.', '' );\n            y = new BigNumber(baseIn);\n            x = y['pow']( str.length - i );\n\n            // Convert str as if an integer, then restore the fraction part by dividing the result\n            // by its base raised to a power. Use toFixed to avoid possible exponential notation.\n            y['c'] = toBaseOut( x.toFixed(), 10, baseOut );\n            y['e'] = y['c'].length;\n        }\n\n        // Convert the number as integer.\n        xc = toBaseOut( str, baseIn, baseOut );\n        e = j = xc.length;\n\n        // Remove trailing zeros.\n        for ( ; xc[--j] == 0; xc.pop() );\n        if ( !xc[0] ) return '0';\n\n        if ( i < 0 ) {\n            --e;\n        } else {\n            x['c'] = xc;\n            x['e'] = e;\n            // sign is needed for correct rounding.\n            x['s'] = sign;\n            x = div( x, y, DECIMAL_PLACES, rm, baseOut );\n            xc = x['c'];\n            r = x['r'];\n            e = x['e'];\n        }\n        d = e + DECIMAL_PLACES + 1;\n\n        // The rounding digit, i.e. the digit after the digit that may be rounded up.\n        i = xc[d];\n        j = baseOut / 2;\n        r = r || d < 0 || xc[d + 1] != null;\n\n        r = rm < 4\n          ? ( i != null || r ) && ( rm == 0 || rm == ( x['s'] < 0 ? 3 : 2 ) )\n          : i > j || i == j &&\n            ( rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == ( x['s'] < 0 ? 8 : 7 ) );\n\n        if ( d < 1 || !xc[0] ) {\n            xc.length = 1;\n            j = 0;\n\n            if (r) {\n\n                // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                xc[0] = 1;\n                e = -DECIMAL_PLACES;\n            } else {\n\n                // Zero.\n                e = xc[0] = 0;\n            }\n        } else {\n            xc.length = d;\n\n            if (r) {\n\n                // Rounding up may mean the previous digit has to be rounded up and so on.\n                for ( --baseOut; ++xc[--d] > baseOut; ) {\n                    xc[d] = 0;\n\n                    if ( !d ) {\n                        ++e;\n                        xc.unshift(1);\n                    }\n                }\n            }\n\n            // Determine trailing zeros.\n            for ( j = xc.length; !xc[--j]; );\n        }\n\n        // E.g. [4, 11, 15] becomes 4bf.\n        for ( i = 0, str = ''; i <= j; str += DIGITS.charAt( xc[i++] ) );\n\n        // Negative exponent?\n        if ( e < 0 ) {\n\n            // Prepend zeros.\n            for ( ; ++e; str = '0' + str );\n            str = '0.' + str;\n\n        // Positive exponent?\n        } else {\n            i = str.length;\n\n            // Append zeros.\n            if ( ++e > i ) {\n                for ( e -= i; e-- ; str += '0' );\n            } else if ( e < i ) {\n                str = str.slice( 0, e ) + '.' + str.slice(e);\n            }\n        }\n\n        // No negative numbers: the caller will add the sign.\n        return str;\n    }\n\n\n    /*\n     * Perform division in the specified base. Called by div and convertBase.\n     */\n    var div = ( function () {\n\n        // Assumes non-zero x and k.\n        function multiply( x, k, base ) {\n            var m, temp, xlo, xhi,\n                carry = 0,\n                i = x.length,\n                klo = k % SQRT_BASE,\n                khi = k / SQRT_BASE | 0;\n\n            for ( x = x.slice(); i--; ) {\n                xlo = x[i] % SQRT_BASE;\n                xhi = x[i] / SQRT_BASE | 0;\n                m = khi * xlo + xhi * klo;\n                temp = klo * xlo + ( ( m % SQRT_BASE ) * SQRT_BASE ) + carry;\n                carry = ( temp / base | 0 ) + ( m / SQRT_BASE | 0 ) + khi * xhi;\n                x[i] = temp % base;\n            }\n            if (carry) x.unshift(carry);\n\n            return x;\n        }\n\n        function compare( a, b, aL, bL ) {\n            var i, cmp;\n\n            if ( aL != bL ) {\n                cmp = aL > bL ? 1 : -1;\n            } else {\n\n                for ( i = cmp = 0; i < aL; i++ ) {\n\n                    if ( a[i] != b[i] ) {\n                        cmp = a[i] > b[i] ? 1 : -1;\n                        break;\n                    }\n                }\n            }\n            return cmp;\n        }\n\n        function subtract( a, b, aL, base ) {\n            var i = 0;\n\n            // Subtract b from a.\n            for ( ; aL--; ) {\n                a[aL] -= i;\n                i = a[aL] < b[aL] ? 1 : 0;\n                a[aL] = i * base + a[aL] - b[aL];\n            }\n\n            // Remove leading zeros.\n            for ( ; !a[0] && a.length > 1; a.shift() );\n        }\n\n        // x: dividend, y: divisor.\n        return function ( x, y, dp, rm, base ) {\n            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\n                yL, yz,\n                s = x['s'] == y['s'] ? 1 : -1,\n                xc = x['c'],\n                yc = y['c'];\n\n            // Either NaN, Infinity or 0?\n            if ( !xc || !xc[0] || !yc || !yc[0] ) {\n\n                return new BigNumber(\n\n                  // Return NaN if either NaN, or both Infinity or 0.\n                  !x['s'] || !y['s'] || ( xc ? yc && xc[0] == yc[0] : !yc ) ? NaN :\n\n                    // Return +-0 if x is 0 or y is +-Infinity, or return +-Infinity as y is 0.\n                    xc && xc[0] == 0 || !yc ? s * 0 : s / 0\n                );\n            }\n\n            q = new BigNumber(s);\n            qc = q['c'] = [];\n            e = x['e'] - y['e'];\n            s = dp + e + 1;\n\n            if ( !base ) {\n                base = BASE;\n\n                //e = mathfloor( x['e'] / LOG_BASE ) - mathfloor( y['e'] / LOG_BASE );\n                e = ( xL = x['e'] / LOG_BASE, i = xL | 0, xL > 0 || xL === i ? i : i - 1 ) -\n                    ( yL = y['e'] / LOG_BASE, i = yL | 0, yL > 0 || yL === i ? i : i - 1 );\n\n                s = s / LOG_BASE | 0;\n            }\n\n            // Result exponent may be one less then the current value of e.\n            // The coefficients of the BigNumbers from convertBase may have trailing zeros.\n            for ( i = 0; yc[i] == ( xc[i] || 0 ); i++ );\n            if ( yc[i] > ( xc[i] || 0 ) ) e--;\n\n            if ( s < 0 ) {\n                qc.push(1);\n                more = true;\n            } else {\n                xL = xc.length;\n                yL = yc.length;\n                i = 0;\n                s += 2;\n\n                /*\n                // TODO: fast path division when divisor < base\n                if ( yL == 1 ) {\n                    n = 0;\n                    yc = yc[0];\n                    s++;\n                    // n is the carry.\n                    for ( ; ( i < xL || n ) && s--; i++ ) {\n                        // Can't use this, it will overflow 2^53.\n                        var t = n * base + ( xc[i] || 0 );\n                        qc[i] = mathfloor( t / yc );\n                        n = t % yc;\n                    }\n                    more = n || i < xL;\n\n                // divisor >= base\n                } else {\n                */\n                    // Normalise xc and yc so highest order digit of yc is >= base/2\n\n                    n = mathfloor( base / ( yc[0] + 1 ) );\n\n                    if ( n > 1 ) {\n                        yc = multiply( yc, n, base );\n                        xc = multiply( xc, n, base );\n                        yL = yc.length;\n                        xL = xc.length;\n                    }\n\n                    xi = yL;\n                    rem = xc.slice( 0, yL );\n                    remL = rem.length;\n\n                    // Add zeros to make remainder as long as divisor.\n                    for ( ; remL < yL; rem[remL++] = 0 );\n                    yz = yc.slice();\n                    yz.unshift(0);\n                    yc0 = yc[0];\n                    if ( yc[1] >= base / 2 ) yc0++;\n\n                    do {\n                        n = 0;\n\n                        // Compare divisor and remainder.\n                        cmp = compare( yc, rem, yL, remL );\n\n                        // If divisor < remainder.\n                        if ( cmp < 0 ) {\n\n                            // Calculate trial digit, n.\n\n                            rem0 = rem[0];\n                            if ( yL != remL ) rem0 = rem0 * base + ( rem[1] || 0 );\n\n                            // n is how many times the divisor goes into the current remainder.\n                            n = mathfloor( rem0 / yc0 );\n\n\n                            //  Algorithm:\n                            //  1. product = divisor * trial digit (n)\n                            //  2. if product > remainder: product -= divisor, n--\n                            //  3. remainder -= product\n                            //  4. if product was < remainder at 2:\n                            //    5. compare new remainder and divisor\n                            //    6. If remainder > divisor: remainder -= divisor, n++\n\n                            if ( n > 1 ) {\n                                if ( n >= base ) n = base - 1;\n\n                                // product = divisor * trial digit.\n                                prod = multiply( yc, n, base );\n                                prodL = prod.length;\n                                remL = rem.length;\n\n                                // Compare product and remainder.\n                                cmp = compare( prod, rem, prodL, remL );\n\n                                // product > remainder.\n                                if ( cmp == 1 ) {\n                                    n--;\n\n                                    // Subtract divisor from product.\n                                    subtract( prod, yL < prodL ? yz : yc, prodL, base );\n                                }\n                            } else {\n\n                                // cmp is -1.\n                                // If n is 0, there is no need to compare yc and rem again below,\n                                // so change cmp to 1 to avoid it.\n                                // If n is 1, compare yc and rem again below.\n                                if ( n == 0 ) cmp = n = 1;\n                                prod = yc.slice();\n                            }\n\n                            prodL = prod.length;\n                            if ( prodL < remL ) prod.unshift(0);\n\n                            // Subtract product from remainder.\n                            subtract( rem, prod, remL, base );\n\n                            // If product was < previous remainder.\n                            if ( cmp == -1 ) {\n                                remL = rem.length;\n\n                                // Compare divisor and new remainder.\n                                cmp = compare( yc, rem, yL, remL );\n\n                                // If divisor < new remainder, subtract divisor from remainder.\n                                if ( cmp < 1 ) {\n                                    n++;\n\n                                    // Subtract divisor from remainder.\n                                    subtract( rem, yL < remL ? yz : yc, remL, base );\n                                }\n                            }\n                            remL = rem.length;\n                        } else if ( cmp === 0 ) {\n                            n++;\n                            rem = [0];\n                        }    // if cmp === 1, n will be 0\n\n                        // Add the next digit, n, to the result array.\n                        qc[i++] = n;\n\n                        // Update the remainder.\n                        if ( cmp && rem[0] ) {\n                            rem[remL++] = xc[xi] || 0;\n                        } else {\n                            rem = [ xc[xi] ];\n                            remL = 1;\n                        }\n                    } while ( ( xi++ < xL || rem[0] != null ) && s-- );\n\n                    more = rem[0] != null;\n                //}\n\n                // Leading zero?\n                if ( !qc[0] ) qc.shift();\n            }\n\n            if ( base == BASE ) {\n\n                // To calculate q.e, first get the number of digits of qc[0].\n                for ( i = 1, s = qc[0]; s >= 10; s /= 10, i++ );\n                rnd( q, dp + ( q['e'] = i + e * LOG_BASE - 1 ) + 1, rm, more );\n\n            // div is being used for base conversion.\n            } else {\n                q['e'] = e;\n                q['r'] = +more;\n            }\n            return q;\n        };\n    })();\n\n\n    /*\n     * Return a string representing the value of BigNumber n in normal or exponential notation\n     * rounded to the specified decimal places or significant digits.\n     *\n     * Called by toString (k: 1), toExponential (k: 1), toFixed (k: undefined), toPrecision (k: 2).\n     * i is the index (with the value in normal notation) of the digit that may be rounded up.\n     * d is the number of digits required including fraction-part trailing zeros.\n     * z is the number of zeros to be appended.\n     */\n    function format( n, i, k ) {\n        var d, str, z,\n            e = ( n = new BigNumber(n) )['e'];\n\n        // i == null when toExponential(no arg), or toString() when x >= toExpPos etc.\n        if ( i == null ) {\n            d = 0;\n        } else {\n            rnd( n, ++i, ROUNDING_MODE );\n\n            // n['e'] may have changed if the value was rounded up.\n            d = k ? i : i + n['e'] - e;\n            e = n['e'];\n        }\n        str = coefficientToString( n['c'] );\n\n        // toPrecision returns exponential notation if the number of significant digits specified\n        // is less than the number of digits necessary to represent the integer part of the value\n        // in normal notation.\n\n        // Exponential notation.\n        if ( k == 1 || k == 2 && ( i <= e || e <= TO_EXP_NEG ) ) {\n\n            // Append zeros?\n            for ( ; str.length < d; str += '0' );\n            if ( str.length > 1 ) str = str.charAt(0) + '.' + str.slice(1);\n            str += ( e < 0 ? 'e' : 'e+' ) + e;\n\n        // Fixed point notation.\n        } else {\n            k = str.length;\n\n            // Negative exponent?\n            if ( e < 0 ) {\n                z = d - k;\n\n                // Prepend zeros.\n                for ( ; ++e; str = '0' + str );\n                str = '0.' + str;\n\n            // Positive exponent?\n            } else {\n\n                if ( ++e > k ) {\n                    z = d - e;\n\n                    // Append zeros.\n                    for ( e -= k; e-- ; str += '0' );\n                    if ( z > 0 ) str += '.';\n                } else {\n                    z = d - k;\n\n                    if ( e < k ) {\n                        str = str.slice( 0, e ) + '.' + str.slice(e);\n                    } else if ( z > 0 ) {\n                        str += '.';\n                    }\n                }\n            }\n\n            // Append more zeros?\n            if ( z > 0 ) for ( ; z--; str += '0' );\n        }\n        return n['s'] < 0 && n['c'][0] ? '-' + str : str;\n    }\n\n\n    // Assemble error messages. Throw BigNumber Errors.\n    function ifExceptionsThrow( arg, i, j, isArray, isRange, isErrors) {\n\n        if (ERRORS) {\n            var error,\n                method = ['new BigNumber', 'cmp', 'div', 'eq', 'gt', 'gte', 'lt',\n                     'lte', 'minus', 'mod', 'plus', 'times', 'toFraction', 'divToInt'\n                    ][ id ? id < 0 ? -id : id : 1 / id < 0 ? 1 : 0 ] + '()',\n                message = outOfRange ? ' out of range' : ' not a' +\n                  ( isRange ? ' non-zero' : 'n' ) + ' integer';\n\n            message = ( [\n                method + ' number type has more than 15 significant digits',\n                method + ' not a base ' + j + ' number',\n                method + ' base' + message,\n                method + ' not a number' ][i] ||\n                  j + '() ' + i + ( isErrors\n                    ? ' not a boolean or binary digit'\n                    : message + ( isArray\n                      ? ' or not [' + ( outOfRange\n                        ? ' negative, positive'\n                        : ' integer, integer' ) + ' ]'\n                      : '' ) ) ) + ': ' + arg;\n\n            outOfRange = id = 0;\n            error = new Error(message);\n            error['name'] = 'BigNumber Error';\n            throw error;\n        }\n    }\n\n\n    /*\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\n     */\n    function rnd( x, sd, rm, r ) {\n        var d, i, j, k, n, ni, rd, xc,\n            pows10 = POWS_TEN;\n\n        // if x is not Infinity or NaN...\n        if ( xc = x['c'] ) {\n\n            // rd: the rounding digit, i.e. the digit after the digit that may be rounded up\n            // n: a base 1e14 number, the value of the element of array x.c containing rd\n            // ni: the index of n within x.c\n            // d: the number of digits of n\n            // i: what would be the index of rd within n if all the numbers were 14 digits long\n            // (i.e. they had leading zeros)\n            // j: if > 0, the actual index of rd within n (if < 0, rd is a leading zero)\n            out: {\n\n                // Get the number of digits of the first element of xc.\n                for ( d = 1, k = xc[0]; k >= 10; k /= 10, d++ );\n                i = sd - d;\n\n                // If the rounding digit is in the first element of xc...\n                if ( i < 0 ) {\n                    i += LOG_BASE;\n                    j = sd;\n                    n = xc[ ni = 0 ];\n\n                    // Get the rounding digit at index j of n.\n                    rd = n / pows10[ d - j - 1 ] % 10 | 0;\n                } else {\n                    ni = Math.ceil( ( i + 1 ) / LOG_BASE );\n\n                    if ( ni >= xc.length ) {\n\n                        if (r) {\n\n                            // Needed by sqrt.\n                            for ( ; xc.length <= ni; xc.push(0) );\n                            n = rd = 0;\n                            d = 1;\n                            i %= LOG_BASE;\n                            j = i - LOG_BASE + 1;\n                        } else {\n                            break out;\n                        }\n                    } else {\n                        n = k = xc[ni];\n\n                        // Get the number of digits of n.\n                        for ( d = 1; k >= 10; k /= 10, d++ );\n\n                        // Get the index of rd within n.\n                        i %= LOG_BASE;\n\n                        // Get the index of rd within n, adjusted for leading zeros.\n                        // The number of leading zeros of n is given by LOG_BASE - d.\n                        j = i - LOG_BASE + d;\n\n                        // Get the rounding digit at index j of n.\n                        rd = j < 0 ? 0 : n / pows10[ d - j - 1 ] % 10 | 0;\n                    }\n                }\n\n                r = r || sd < 0 ||\n\n                // Are there any non-zero digits after the rounding digit?\n                // The expression  n % pows10[ d - j - 1 ]  returns all the digits of n to the right\n                // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\n                  xc[ni + 1] != null || ( j < 0 ? n : n % pows10[ d - j - 1 ] );\n\n                r = rm < 4\n                  ? ( rd || r ) && ( rm == 0 || rm == ( x['s'] < 0 ? 3 : 2 ) )\n                  : rd > 5 || rd == 5 && ( rm == 4 || r || rm == 6 &&\n\n                    // Check whether the digit to the left of the rounding digit is odd.\n                    ( ( i > 0 ? j > 0 ? n / pows10[ d - j ] : 0 : xc[ni - 1] ) % 10 ) & 1 ||\n                      rm == ( x['s'] < 0 ? 8 : 7 ) );\n\n                if ( sd < 1 || !xc[0] ) {\n                    xc.length = 0;\n\n                    if (r) {\n\n                        // Convert sd to decimal places.\n                        sd -= x['e'] + 1;\n\n                        // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                        xc[0] = pows10[ sd % LOG_BASE ];\n                        x['e'] = -sd || 0;\n                    } else {\n\n                        // Zero.\n                        xc[0] = x['e'] = 0;\n                    }\n\n                    return x;\n                }\n\n                // Remove excess digits.\n                if ( i == 0 ) {\n                    xc.length = ni;\n                    k = 1;\n                    ni--;\n                } else {\n                    xc.length = ni + 1;\n                    k = pows10[ LOG_BASE - i ];\n\n                    // E.g. 56700 becomes 56000 if 7 is the rounding digit.\n                    // j > 0 means i > number of leading zeros of n.\n                    xc[ni] = j > 0 ? mathfloor( n / pows10[ d - j ] % pows10[j] ) * k : 0;\n                }\n\n                // Round up?\n                if (r) {\n\n                    for ( ; ; ) {\n\n                        // If the digit to be rounded up is in the first element of xc...\n                        if ( ni == 0 ) {\n\n                            // i will be the length of xc[0] before k is added.\n                            for ( i = 1, j = xc[0]; j >= 10; j /= 10, i++ );\n                            j = xc[0] += k;\n                            for ( k = 1; j >= 10; j /= 10, k++ );\n\n                            // if i != k the length has increased.\n                            if ( i != k ) {\n                                x['e']++;\n                                if ( xc[0] == BASE ) xc[0] = 1;\n                            }\n                            break;\n                        } else {\n                            xc[ni] += k;\n                            if ( xc[ni] != BASE ) break;\n                            xc[ni--] = 0;\n                            k = 1;\n                        }\n                    }\n                }\n\n                // Remove trailing zeros.\n                for ( i = xc.length; xc[--i] === 0; xc.pop() );\n            }\n\n            // Overflow? Infinity.\n            if ( x['e'] > MAX_EXP ) {\n                x['c'] = x['e'] = null;\n\n            // Underflow? Zero.\n            } else if ( x['e'] < MIN_EXP ) {\n                x['c'] = [ x['e'] = 0 ];\n            }\n        }\n\n        return x;\n    }\n\n\n    // PROTOTYPE/INSTANCE METHODS\n\n\n    /*\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.\n     */\n    P['absoluteValue'] = P['abs'] = function () {\n        var x = new BigNumber(this);\n        if ( x['s'] < 0 ) x['s'] = 1;\n        return x;\n    };\n\n\n    /*\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole number\n     * in the direction of Infinity.\n     */\n    P['ceil'] = function () {\n        return rnd( new BigNumber(this), this['e'] + 1, 2 );\n    };\n\n\n    /*\n     * Return\n     * 1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\n     * -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\n     * 0 if they have the same value,\n     * or null if the value of either is NaN.\n     */\n    P['comparedTo'] = P['cmp'] = function ( y, b ) {\n        var a,\n            x = this,\n            xc = x['c'],\n            yc = ( id = -id, y = new BigNumber( y, b ) )['c'],\n            i = x['s'],\n            j = y['s'],\n            k = x['e'],\n            l = y['e'];\n\n        // Either NaN?\n        if ( !i || !j ) return null;\n\n        a = xc && !xc[0];\n        b = yc && !yc[0];\n\n        // Either zero?\n        if ( a || b ) return a ? b ? 0 : -j : i;\n\n        // Signs differ?\n        if ( i != j ) return i;\n\n        a = i < 0;\n        b = k == l;\n\n        // Either Infinity?\n        if ( !xc || !yc ) return b ? 0 : !xc ^ a ? 1 : -1;\n\n        // Compare exponents.\n        if ( !b ) return k > l ^ a ? 1 : -1;\n        i = -1;\n        j = ( k = xc.length ) < ( l = yc.length ) ? k : l;\n\n        // Compare digit by digit.\n        for ( ; ++i < j; ) if ( xc[i] != yc[i] ) return xc[i] > yc[i] ^ a ? 1 : -1;\n\n        // Compare lengths.\n        return k == l ? 0 : k > l ^ a ? 1 : -1;\n    };\n\n\n    /*\n     * Return the number of decimal places of the value of this BigNumber, or null if the value of\n     * this BigNumber is +-Infinity or NaN.\n     */\n    P['decimalPlaces'] = P['dp'] = function () {\n        var n, v,\n            c = this['c'];\n\n        if ( !c ) return null;\n        n = ( ( v = c.length - 1 ) - mathfloor( this['e'] / LOG_BASE ) ) * LOG_BASE;\n\n        // Subtract the number of trailing zeros of the last number.\n        if ( v = c[v] ) for ( ; v % 10 == 0; v /= 10, n-- );\n        if ( n < 0 ) n = 0;\n\n        return n;\n    };\n\n\n    /*\n     *  n / 0 = I\n     *  n / N = N\n     *  n / I = 0\n     *  0 / n = 0\n     *  0 / 0 = N\n     *  0 / N = N\n     *  0 / I = 0\n     *  N / n = N\n     *  N / 0 = N\n     *  N / N = N\n     *  N / I = N\n     *  I / n = I\n     *  I / 0 = I\n     *  I / N = N\n     *  I / I = N\n     *\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\n     */\n    P['dividedBy'] = P['div'] = function ( y, b ) {\n        id = 2;\n        return div( this, new BigNumber( y, b ), DECIMAL_PLACES, ROUNDING_MODE );\n    };\n\n\n    /*\n     * Return a new BigNumber whose value is the integer part of dividing the value of this\n     * BigNumber by the value of BigNumber(y, b).\n     */\n    P['dividedToIntegerBy'] = P['divToInt'] = function ( y, b ) {\n        id = 13;\n        return div( this, new BigNumber( y, b ), 0, 1 );\n    };\n\n\n    /*\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(n, b),\n     * otherwise returns false.\n     */\n    P['equals'] = P['eq'] = function ( n, b ) {\n        id = 3;\n        return this['cmp']( n, b ) === 0;\n    };\n\n\n    /*\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole number\n     * in the direction of -Infinity.\n     */\n    P['floor'] = function () {\n        return rnd( new BigNumber(this), this['e'] + 1, 3 );\n    };\n\n\n    /*\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(n, b),\n     * otherwise returns false.\n     */\n    P['greaterThan'] = P['gt'] = function ( n, b ) {\n        id = 4;\n        return this['cmp']( n, b ) > 0;\n    };\n\n\n    /*\n     * Return true if the value of this BigNumber is greater than or equal to the value of\n     * BigNumber(n, b), otherwise returns false.\n     */\n    P['greaterThanOrEqualTo'] = P['gte'] = function ( n, b ) {\n        id = 5;\n        return ( b = this['cmp']( n, b ) ) == 1 || b === 0;\n    };\n\n\n    /*\n     * Return true if the value of this BigNumber is a finite number, otherwise returns false.\n     */\n    P['isFinite'] = function () {\n        return !!this['c'];\n    };\n\n\n    /*\n     * Return true if the value of this BigNumber is an integer, otherwise return false.\n     */\n    P['isInteger'] = P['isInt'] = function () {\n        return !!this['c'] && mathfloor( this['e'] / LOG_BASE ) > this['c'].length - 2;\n    };\n\n\n    /*\n     * Return true if the value of this BigNumber is NaN, otherwise returns false.\n     */\n    P['isNaN'] = function () {\n        return !this['s'];\n    };\n\n\n    /*\n     * Return true if the value of this BigNumber is negative, otherwise returns false.\n     */\n    P['isNegative'] = P['isNeg'] = function () {\n        return this['s'] < 0;\n    };\n\n\n    /*\n     * Return true if the value of this BigNumber is 0 or -0, otherwise returns false.\n     */\n    P['isZero'] = function () {\n        return !!this['c'] && this['c'][0] == 0;\n    };\n\n\n    /*\n     * Return true if the value of this BigNumber is less than the value of BigNumber(n, b),\n     * otherwise returns false.\n     */\n    P['lessThan'] = P['lt'] = function ( n, b ) {\n        id = 6;\n        return this['cmp']( n, b ) < 0;\n    };\n\n\n    /*\n     * Return true if the value of this BigNumber is less than or equal to the value of\n     * BigNumber(n, b), otherwise returns false.\n     */\n    P['lessThanOrEqualTo'] = P['lte'] = function ( n, b ) {\n        id = 7;\n        return ( b = this['cmp']( n, b ) ) == -1 || b === 0;\n    };\n\n\n    /*\n     *  n - 0 = n\n     *  n - N = N\n     *  n - I = -I\n     *  0 - n = -n\n     *  0 - 0 = 0\n     *  0 - N = N\n     *  0 - I = -I\n     *  N - n = N\n     *  N - 0 = N\n     *  N - N = N\n     *  N - I = N\n     *  I - n = I\n     *  I - 0 = I\n     *  I - N = N\n     *  I - I = N\n     *\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of\n     * BigNumber(y, b).\n     */\n    P['minus'] = function ( y, b ) {\n        var i, j, t, xLTy,\n            x = this,\n            a = x['s'];\n\n        id = 8;\n        y = new BigNumber( y, b );\n        b = y['s'];\n\n        // Either NaN?\n        if ( !a || !b ) return new BigNumber(NaN);\n\n        // Signs differ?\n        if ( a != b ) {\n            y['s'] = -b;\n            return x['plus'](y);\n        }\n\n        var xe = x['e'] / LOG_BASE,\n            ye = y['e'] / LOG_BASE,\n            xc = x['c'],\n            yc = y['c'];\n\n        if ( !xe || !ye ) {\n\n            // Either Infinity?\n            if ( !xc || !yc ) return xc ? ( y['s'] = -b, y ) : new BigNumber( yc ? x : NaN );\n\n            // Either zero?\n            if ( !xc[0] || !yc[0] ) {\n\n                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\n                return yc[0] ? ( y['s'] = -b, y ) : new BigNumber( xc[0] ? x :\n\n                  // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\n                  ROUNDING_MODE == 3 ? -0 : 0 );\n            }\n        }\n\n        // Floor xe and ye\n        i = xe | 0;\n        xe = xe > 0 || xe === i ? i : i - 1;\n        i = ye | 0;\n        ye = ye > 0 || ye === i ? i : i - 1;\n        xc = xc.slice();\n\n        // Determine which is the bigger number.\n        if ( a = xe - ye ) {\n\n            if ( xLTy = a < 0 ) {\n                a = -a, t = xc;\n            } else {\n                ye = xe, t = yc;\n            }\n\n            // Prepend zeros to equalise exponents.\n            for ( t.reverse(), b = a; b--; t.push(0) );\n            t.reverse();\n        } else {\n\n            // Exponents equal. Check digit by digit.\n            j = ( xLTy = ( a = xc.length ) < ( b = yc.length ) ) ? a : b;\n\n            for ( a = b = 0; b < j; b++ ) {\n\n                if ( xc[b] != yc[b] ) {\n                    xLTy = xc[b] < yc[b];\n                    break;\n                }\n            }\n        }\n\n        // x < y? Point xc to the array of the bigger number.\n        if (xLTy) t = xc, xc = yc, yc = t, y['s'] = -y['s'];\n\n        b = ( j = yc.length ) - ( i = xc.length );\n\n        // Append zeros to xc if shorter.\n        // No need to add zeros to yc if shorter as subtraction only needs to start at yc.length.\n        if ( b > 0 ) for ( ; b--; xc[i++] = 0 );\n        b = BASE - 1;\n\n        // Subtract yc from xc.\n        for ( ; j > a; ) {\n\n            if ( xc[--j] < yc[j] ) {\n                for ( i = j; i && !xc[--i]; xc[i] = b );\n                --xc[i];\n                xc[j] += BASE;\n            }\n            xc[j] -= yc[j];\n        }\n\n        // Remove leading zeros and adjust exponent accordingly.\n        for ( ; xc[0] == 0; xc.shift(), --ye );\n\n        // Zero?\n        if ( !xc[0] ) {\n\n            // Following IEEE 754 (2008) 6.3,\n            // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\n            y['s'] = ROUNDING_MODE == 3 ? -1 : 1;\n            y['c'] = [ y['e'] = 0 ];\n            return y;\n        }\n\n        // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity when neither\n        // x or y are Infinity.\n        return normalise( y, xc, ye );\n    };\n\n\n    /*\n     *   n % 0 =  N\n     *   n % N =  N\n     *   0 % n =  0\n     *  -0 % n = -0\n     *   0 % 0 =  N\n     *   0 % N =  N\n     *   N % n =  N\n     *   N % 0 =  N\n     *   N % N =  N\n     *\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\n     * BigNumber(y, b).\n     */\n    P['modulo'] = P['mod'] = function ( y, b ) {\n        id = 9;\n        var x = this,\n            xc = x['c'],\n            yc = ( y = new BigNumber( y, b ) )['c'],\n            xs = x['s'],\n            ys = y['s'];\n\n        // x or y NaN? y zero? x zero?\n        b = !xs || !ys || yc && !yc[0];\n        if ( b || xc && !xc[0] ) return new BigNumber( b ? NaN : x );\n\n        x['s'] = y['s'] = 1;\n        b = y['cmp'](x) == 1;\n        x['s'] = xs;\n        y['s'] = ys;\n\n        return b ? new BigNumber(x) : x['minus']( div( x, y, 0, 1 )['times'](y) );\n    };\n\n\n    /*\n     * Return a new BigNumber whose value is the value of this BigNumber negated, i.e. multiplied\n     * by -1.\n     */\n    P['negated'] = P['neg'] = function () {\n        var x = new BigNumber(this);\n        x['s'] = -x['s'] || null;\n        return x;\n    };\n\n\n    /*\n     *  n + 0 = n\n     *  n + N = N\n     *  n + I = I\n     *  0 + n = n\n     *  0 + 0 = 0\n     *  0 + N = N\n     *  0 + I = I\n     *  N + n = N\n     *  N + 0 = N\n     *  N + N = N\n     *  N + I = N\n     *  I + n = I\n     *  I + 0 = I\n     *  I + N = N\n     *  I + I = I\n     *\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of\n     * BigNumber(y, b).\n     */\n    P['plus'] = function ( y, b ) {\n        var t,\n            x = this,\n            a = x['s'];\n\n        id = 10;\n        y = new BigNumber( y, b );\n        b = y['s'];\n\n        // Either NaN?\n        if ( !a || !b ) return new BigNumber(NaN);\n\n        // Signs differ?\n         if ( a != b ) {\n            y['s'] = -b;\n            return x['minus'](y);\n        }\n\n        var xe = x['e'] / LOG_BASE,\n            ye = y['e'] / LOG_BASE,\n            xc = x['c'],\n            yc = y['c'];\n\n        if ( !xe || !ye ) {\n\n            // Return +-Infinity if either Infinity.\n            if ( !xc || !yc ) return new BigNumber( a / 0 );\n\n            // Either zero? Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\n            if ( !xc[0] || !yc[0] ) return yc[0] ? y : new BigNumber( xc[0] ? x : a * 0 );\n        }\n\n         // Floor xe and ye\n        a = xe | 0;\n        xe = xe > 0 || xe === a ? a : a - 1;\n        a = ye | 0;\n        ye = ye > 0 || ye === a ? a : a - 1;\n        xc = xc.slice();\n\n        // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\n        if ( a = xe - ye ) {\n            if ( a > 0 ) {\n                ye = xe, t = yc;\n            } else {\n                a = -a, t = xc;\n            }\n\n            for ( t.reverse(); a--; t.push(0) );\n            t.reverse();\n        }\n        a = xc.length;\n        b = yc.length;\n\n        // Point xc to the longer array, and b to the shorter length.\n        if ( a - b < 0 ) t = yc, yc = xc, xc = t, b = a;\n\n        // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\n        for ( a = 0; b; ) {\n            a = ( xc[--b] = xc[b] + yc[b] + a ) / BASE | 0;\n            xc[b] %= BASE;\n        }\n\n\n        if (a) {\n            xc.unshift(a);\n            ++ye;\n        }\n\n        // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n        // ye = MAX_EXP + 1 possible\n        return normalise( y, xc, ye );\n    };\n\n\n    /*\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of dp\n     * decimal places using rounding mode rm, or to 0 and ROUNDING_MODE respectively if omitted.\n     *\n     * [dp] {number} Integer, 0 to MAX inclusive.\n     * [rm] {number} Integer, 0 to 8 inclusive.\n     */\n    P['round'] = function ( dp, rm ) {\n\n        dp = dp == null || ( ( ( outOfRange = dp < 0 || dp > MAX ) || parse(dp) != dp ) &&\n\n          // 'round() decimal places out of range: {dp}'\n          // 'round() decimal places not an integer: {dp}'\n          !ifExceptionsThrow( dp, 'decimal places', 'round' ) ) ? 0 : dp | 0;\n\n        // Include '&& rm !== 0' because with Opera -0 == parseFloat(-0) is false.\n        rm = rm == null || ( ( ( outOfRange = rm < 0 || rm > 8 ) || parse(rm) != rm && rm !== 0 ) &&\n\n          // 'round() mode not an integer: {rm}'\n          // 'round() mode out of range: {rm}'\n          !ifExceptionsThrow( rm, 'mode', 'round' ) ) ? ROUNDING_MODE : rm | 0;\n\n        return rnd( new BigNumber(this), dp + this['e'] + 1, rm );\n    };\n\n\n    /*\n     *  sqrt(-n) =  N\n     *  sqrt( N) =  N\n     *  sqrt(-I) =  N\n     *  sqrt( I) =  I\n     *  sqrt( 0) =  0\n     *  sqrt(-0) = -0\n     *\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\n     */\n    P['squareRoot'] = P['sqrt'] = function () {\n        var m, n, r, rep, t,\n            x = this,\n            c = x['c'],\n            s = x['s'],\n            e = x['e'],\n            dp = DECIMAL_PLACES + 4,\n            half = new BigNumber('0.5');\n\n        // Negative/NaN/Infinity/zero?\n        if ( s !== 1 || !c || !c[0] ) {\n            return new BigNumber( !s || s < 0 && ( !c || c[0] ) ? NaN : c ? x : 1 / 0 );\n        }\n\n        // Initial estimate.\n        s = Math.sqrt( +x );\n\n        // Math.sqrt underflow/overflow?\n        // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\n        if ( s == 0 || s == 1 / 0 ) {\n            n = coefficientToString(c);\n            if ( ( n.length + e ) % 2 == 0 ) n += '0';\n            s = Math.sqrt(n);\n            e = mathfloor( ( e + 1 ) / 2 ) - ( e < 0 || e % 2 );\n\n            if ( s == 1 / 0 ) {\n                n = '1e' + e;\n            } else {\n                n = s.toExponential();\n                n = n.slice( 0, n.indexOf('e') + 1 ) + e;\n            }\n            r = new BigNumber(n);\n        } else {\n            r = new BigNumber( s.toString() );\n        }\n\n        // Check for zero. r could be zero if MIN_EXP is changed after the this value was created.\n        // This would cause a division by zero (x/t) and hence Infinity below, which would cause\n        // coefficientToString to throw.\n        if ( r['c'][0] ) {\n            e = r['e'];\n            s = e + dp;\n            if ( s < 3 ) s = 0;\n\n            // Newton-Raphson iteration.\n            for ( ; ; ) {\n                t = r;\n                r = half['times']( t['plus']( div( x, t, dp, 1 ) ) );\n\n                if ( coefficientToString( t['c']   ).slice( 0, s ) === ( n =\n                     coefficientToString( r['c'] ) ).slice( 0, s ) ) {\n\n                    // The exponent of r may here be one less than the final result exponent,\n                    // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits are\n                    // indexed correctly.\n                    if ( r['e'] < e ) --s;\n                    n = n.slice( s - 3, s + 1 );\n\n                    // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are\n                    // 9999 or 4999 (i.e. approaching a rounding boundary) continue the iteration.\n                    if ( n == '9999' || !rep && n == '4999' ) {\n\n                        // On the first iteration only, check to see if rounding up gives the exact\n                        // result as the nines may infinitely repeat.\n                        if ( !rep ) {\n                            rnd( t, t['e'] + DECIMAL_PLACES + 2, 0 );\n\n                            if ( t['times'](t)['eq'](x) ) {\n                                r = t;\n                                break;\n                            }\n                        }\n                        dp += 4;\n                        s += 4;\n                        rep = 1;\n                    } else {\n\n                        // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact result.\n                        // If not, then there are further digits and m will be truthy.\n                        if ( !+n || !+n.slice(1) && n.charAt(0) == '5' ) {\n\n                            // Truncate to the first rounding digit.\n                            rnd( r, r['e'] + DECIMAL_PLACES + 2, 1 );\n                            m = !r['times'](r)['eq'](x);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        return rnd( r, r['e'] + DECIMAL_PLACES + 1, ROUNDING_MODE, m );\n    };\n\n\n    /*\n     *  n * 0 = 0\n     *  n * N = N\n     *  n * I = I\n     *  0 * n = 0\n     *  0 * 0 = 0\n     *  0 * N = N\n     *  0 * I = N\n     *  N * n = N\n     *  N * 0 = N\n     *  N * N = N\n     *  N * I = N\n     *  I * n = I\n     *  I * 0 = N\n     *  I * N = N\n     *  I * I = I\n     *\n     * Return a new BigNumber whose value is the value of this BigNumber times the value of\n     * BigNumber(y, b).\n     */\n    P['times'] = function ( y, b ) {\n        var c, e, k, m, r, xlo, xhi, ylo, yhi,\n            x = this,\n            xc = x['c'],\n            yc = ( id = 11, y = new BigNumber( y, b ) )['c'],\n            i = x['e'] / LOG_BASE,\n            j = y['e'] / LOG_BASE,\n            a = x['s'];\n\n        y['s'] = a == ( b = y['s'] ) ? 1 : -1;\n\n        // Either NaN/Infinity/0?\n        if ( !i && ( !xc || !xc[0] ) || !j && ( !yc || !yc[0] ) ) {\n\n            // Return NaN if either NaN, or x is 0 and y is Infinity, or y is 0 and x is Infinity.\n            return new BigNumber( !a || !b || xc && !xc[0] && !yc || yc && !yc[0] && !xc ? NaN\n\n              // Return +-Infinity if either is Infinity. Return +-0 if x or y is 0.\n              : !xc || !yc ? y['s'] / 0 : y['s'] * 0 );\n        }\n\n        // e = mathfloor(i) + mathfloor(j);\n        e = ( e = i | 0, i > 0 || i === e ? e : e - 1) +\n            ( e = j | 0, j > 0 || j === e ? e : e - 1);\n\n        a = xc.length;\n        b = yc.length;\n\n        // Ensure xc points to longer array and b to longer length.\n        if ( a < b ) r = xc, xc = yc, yc = r, j = a, a = b, b = j;\n\n        // Initialise the result array with zeros.\n        for ( j = a + b, r = []; j--; r.push(0) );\n\n        // Multiply!\n        for ( i = b; --i >= 0; ) {\n            c = 0;\n            j = a + i;\n            k = a;\n            ylo = yc[i] % SQRT_BASE;\n            yhi = yc[i] / SQRT_BASE | 0;\n\n            for ( ; j > i; ) {\n                xlo = xc[--k] % SQRT_BASE;\n                xhi = xc[k] / SQRT_BASE | 0;\n                m = yhi * xlo + xhi * ylo;\n                xlo = ylo * xlo + ( ( m % SQRT_BASE ) * SQRT_BASE ) + r[j] + c;\n                c = ( xlo / BASE | 0 ) + ( m / SQRT_BASE | 0 ) + yhi * xhi;\n                r[j--] = xlo % BASE;\n            }\n            r[j] = c;\n        }\n\n        if (c) {\n            ++e;\n        } else {\n            r.shift();\n        }\n\n        return normalise( y, r, e );\n    };\n\n\n    /*\n     * Return a string representing the value of this BigNumber in exponential notation to dp fixed\n     * decimal places and rounded using ROUNDING_MODE if necessary.\n     *\n     * [dp] {number} Integer, 0 to MAX inclusive.\n     */\n    P['toExponential'] = function (dp) {\n        var x = this;\n\n        return x['c'] ? format( x, dp == null || ( ( outOfRange = dp < 0 || dp > MAX ) ||\n\n          // Include '&& dp !== 0' because with Opera -0 == parseFloat(-0) is false,\n          // despite -0 == parseFloat('-0') && 0 == -0 being true.\n          parse(dp) != dp && dp !== 0 ) &&\n\n            // 'toExponential() decimal places not an integer: {dp}'\n            // 'toExponential() decimal places out of range: {dp}'\n            !ifExceptionsThrow( dp, 'decimal places', 'toExponential' )\n              ? null : dp | 0, 1 ) : x.toString();\n    };\n\n\n    /*\n     * Return a string representing the value of this BigNumber in normal notation to dp fixed\n     * decimal places and rounded using ROUNDING_MODE if necessary.\n     *\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\n     * but e.g. (-0.00001).toFixed(0) is '-0'.\n     *\n     * [dp] {number} Integer, 0 to MAX inclusive.\n     */\n    P['toFixed'] = function (dp) {\n        var str,\n            x = this,\n            neg = TO_EXP_NEG,\n            pos = TO_EXP_POS;\n\n        dp = dp == null || ( ( outOfRange = dp < 0 || dp > MAX ) ||\n\n          // 'toFixed() decimal places not an integer: {dp}'\n          // 'toFixed() decimal places out of range: {dp}'\n          parse(dp) != dp && dp !== 0 ) && !ifExceptionsThrow( dp, 'decimal places', 'toFixed' )\n            ? null : x['e'] + ( dp | 0 );\n\n        TO_EXP_NEG = -( TO_EXP_POS = 1 / 0 );\n\n        if ( dp == null || !x['c'] ) {\n            str = x.toString();\n        } else {\n            str = format( x, dp );\n\n            // (-0).toFixed() is '0', but (-0.1).toFixed() is '-0'.\n            // (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\n            if ( x['s'] < 0 && x['c'] ) {\n\n                // As e.g. (-0).toFixed(3), will wrongly be returned as -0.000 from toString.\n                if ( !x['c'][0] ) {\n                    str = str.replace( '-', '' );\n\n                // As e.g. -0.5 if rounded to -0 will cause toString to omit the minus sign.\n                } else if ( str.indexOf('-') < 0 ) {\n                    str = '-' + str;\n                }\n            }\n        }\n\n        TO_EXP_NEG = neg;\n        TO_EXP_POS = pos;\n\n        return str;\n    };\n\n\n    /*\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded\n     * using ROUNDING_MODE to dp decimal places, and formatted according to the properties of the\n     * FORMAT object (see BigNumber.config).\n     *\n     * FORMAT = {\n     *      decimalSeparator : '.',\n     *      groupSeparator : ',',\n     *      groupSize : 3,\n     *      secondaryGroupSize : 0,\n     *      fractionGroupSeparator : '\\xA0',    // non-breaking space\n     *      fractionGroupSize : 0\n     * };\n     *\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\n     * (TODO: If dp is invalid the error message will give toFixed as the offending method.)\n     */\n    P['toFormat'] = function (dp) {\n        var x = this;\n\n        if ( !x['c'] ) return x.toString();\n\n        var i,\n            isNeg = x['s'] < 0,\n            groupSeparator = FORMAT['groupSeparator'],\n            g1 = +FORMAT['groupSize'],\n            g2 = +FORMAT['secondaryGroupSize'],\n            arr = x.toFixed(dp).split('.'),\n            intPart = arr[0],\n            fractionPart = arr[1],\n            intDigits = isNeg ? intPart.slice(1) : intPart,\n            len = intDigits.length;\n\n        if (g2) i = g1, g1 = g2, g2 = i, len -= i;\n\n        if ( g1 > 0 && len > 0 ) {\n            i = len % g1 || g1;\n            intPart = intDigits.substr( 0, i );\n            for ( ; i < len; i += g1 ) intPart += groupSeparator + intDigits.substr( i, g1 );\n            if ( g2 > 0 ) intPart += groupSeparator + intDigits.slice(i);\n            if (isNeg) intPart = '-' + intPart;\n        }\n\n        return fractionPart\n          ? intPart + FORMAT['decimalSeparator'] + ( ( g2 = +FORMAT['fractionGroupSize'] )\n            ? fractionPart.replace( new RegExp( '\\\\d{' + g2 + '}\\\\B', 'g' ),\n              '$&' + FORMAT['fractionGroupSeparator'] )\n            : fractionPart )\n          : intPart;\n    };\n\n\n    /*\n     * Return a string array representing the value of this BigNumber as a simple fraction with an\n     * integer numerator and an integer denominator. The denominator will be a positive non-zero\n     * value less than or equal to the specified maximum denominator. If a maximum denominator is\n     * not specified, the denominator will be the lowest value necessary to represent the number\n     * exactly.\n     *\n     * [maxD] {number|string|BigNumber} Integer >= 1 and < Infinity.\n     */\n    P['toFraction'] = function (maxD) {\n        var arr, d0, d2, e, exp, n, n0, q, s,\n            n1 = d0 = new BigNumber(ONE),\n            d1 = n0 = new BigNumber(ONE),\n            x = this,\n            xc = x['c'],\n            d = new BigNumber(ONE);\n\n        // NaN, Infinity.\n        if ( !xc ) return x.toString();\n        s = coefficientToString(xc);\n\n        // Initial denominator.\n        e = d['e'] = s.length - x['e'] - 1;\n        d['c'][0] = POWS_TEN[ ( exp = e % LOG_BASE ) < 0 ? LOG_BASE + exp : exp ];\n\n        // If max denominator is undefined or null, or NaN...\n        if ( maxD == null || ( !( id = 12, n = new BigNumber(maxD) )['s'] ||\n\n               // or less than 1, or Infinity...\n               ( outOfRange = n['cmp'](n1) < 0 || !n['c'] ) ||\n\n                 // or not an integer...\n                 ( ERRORS && mathfloor( n['e'] / LOG_BASE ) < n['c'].length - 1 ) ) &&\n\n                   // 'toFraction() max denominator not an integer: {maxD}'\n                   // 'toFraction() max denominator out of range: {maxD}'\n                   !ifExceptionsThrow( maxD, 'max denominator', 'toFraction' ) ||\n\n                     // or greater than the max denominator needed to specify the value exactly...\n                     ( maxD = n )['cmp'](d) > 0 ) {\n\n            // d is e.g. 10, 100, 1000, 10000... , n1 is 1.\n            maxD = e > 0 ? d : n1;\n        }\n\n        exp = MAX_EXP;\n        MAX_EXP = 1 / 0;\n        n = new BigNumber(s);\n\n        // n0 = d1 = 0\n        n0['c'][0] = 0;\n\n        for ( ; ; )  {\n            q = div( n, d, 0, 1 );\n            d2 = d0['plus']( q['times'](d1) );\n            if ( d2['cmp'](maxD) == 1 ) break;\n            d0 = d1;\n            d1 = d2;\n            n1 = n0['plus']( q['times']( d2 = n1 ) );\n            n0 = d2;\n            d = n['minus']( q['times']( d2 = d ) );\n            n = d2;\n        }\n\n        d2 = div( maxD['minus'](d0), d1, 0, 1 );\n        n0 = n0['plus']( d2['times'](n1) );\n        d0 = d0['plus']( d2['times'](d1) );\n        n0['s'] = n1['s'] = x['s'];\n        e *= 2;\n\n        // Determine which fraction is closer to x, n0/d0 or n1/d1\n        arr = div( n1, d1, e, ROUNDING_MODE )['minus'](x)['abs']()['cmp'](\n              div( n0, d0, e, ROUNDING_MODE )['minus'](x)['abs']() ) < 1\n                ? [ n1.toString(), d1.toString() ]\n                : [ n0.toString(), d0.toString() ];\n\n        MAX_EXP = exp;\n\n        return arr;\n    };\n\n\n    /*\n     * Return the value of this BigNumber converted to a number primitive.\n     */\n    P['toNumber'] = function () {\n        var x = this;\n\n        // Ensure zero has correct sign.\n        return +x || ( x['s'] ? 0 * x['s'] : NaN );\n    };\n\n\n    /*\n     * Return a BigNumber whose value is the value of this BigNumber raised to the power e.\n     * If e is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\n     *\n     * e {number} Integer, -MAX_POWER to MAX_POWER inclusive.\n     */\n    P['toPower'] = P['pow'] = function (e) {\n\n        // e to integer, avoiding NaN or Infinity becoming 0.\n        var i = e * 0 == 0 ? ~~e : e,\n            x = new BigNumber(this),\n            y = new BigNumber(ONE);\n\n        // Pass +-Infinity for out of range exponents.\n        if ( ( ( ( outOfRange = e < -MAX_POWER || e > MAX_POWER ) && (i = e * 1 / 0) ) ||\n\n            // Any exponent that fails the parse becomes NaN.\n            // Include 'e !== 0' because on Opera  -0 == parseFloat(-0)  is false, despite\n            // -0 === parseFloat(-0) && -0 == parseFloat('-0')  evaluating true.\n            parse(e) != e && e !== 0 && !(i = NaN) ) &&\n\n              // 'pow() exponent not an integer: {e}'\n              // 'pow() exponent out of range: {e}'\n              // Pass zero to Math.pow, as any value to the power zero is 1.\n              !ifExceptionsThrow( e, 'exponent', 'pow' ) || !i ) {\n\n            // i is +-Infinity, NaN or 0.\n            return new BigNumber( Math.pow( +x, i ) );\n        }\n        i = i < 0 ? -i : i;\n\n        for ( ; ; ) {\n            if ( i & 1 ) y = y['times'](x);\n            i >>= 1;\n            if ( !i ) break;\n            x = x['times'](x);\n        }\n\n        return e < 0 ? ONE['div'](y) : y;\n    };\n\n\n    /*\n     * Return a string representing the value of this BigNumber to sd significant digits and rounded\n     * using ROUNDING_MODE if necessary. If sd is less than the number of digits necessary to\n     * represent the integer part of the value in normal notation, then use exponential notation.\n     *\n     * sd {number} Integer, 1 to MAX inclusive.\n     */\n    P['toPrecision'] = function (sd) {\n        var x = this;\n\n         // ERRORS true: Throw if sd not undefined, null or an integer in range.\n         // ERRORS false: Ignore sd if not a number or not in range.\n         // Truncate non-integers.\n        return sd == null || ( ( ( outOfRange = sd < 1 || sd > MAX ) || parse(sd) != sd ) &&\n\n          // 'toPrecision() precision not an integer: {sd}'\n          // 'toPrecision() precision out of range: {sd}'\n          !ifExceptionsThrow( sd, 'precision', 'toPrecision' ) ) || !x['c']\n            ? x.toString() : format( x, --sd | 0, 2 );\n    };\n\n\n    /*\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent that is\n     * equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than TO_EXP_NEG,\n     * return exponential notation.\n     *\n     * [b] {number} Integer, 2 to 64 inclusive.\n     */\n    P['toString'] = function (b) {\n        var u, str, strL,\n            x = this,\n            xe = x['e'];\n\n        // Infinity or NaN?\n        if ( xe === null ) {\n            str = x['s'] ? 'Infinity' : 'NaN';\n\n        // Exponential format?\n        } else if ( b == u && ( xe <= TO_EXP_NEG || xe >= TO_EXP_POS ) ) {\n            return format( x, u, 1 );\n        } else {\n            str = coefficientToString( x['c'] );\n\n            // Negative exponent?\n            if ( xe < 0 ) {\n\n                // Prepend zeros.\n                for ( ; ++xe; str = '0' + str );\n                str = '0.' + str;\n\n            // Positive exponent?\n            } else if ( strL = str.length, xe > 0 ) {\n\n                // Append zeros.\n                if ( ++xe > strL ) {\n                    for ( xe -= strL; xe-- ; str += '0' );\n                } else if ( xe < strL ) {\n                    str = str.slice( 0, xe ) + '.' + str.slice(xe);\n                }\n\n            // Exponent zero.\n            } else {\n                u = str.charAt(0);\n\n                if ( strL > 1 ) {\n                    str = u + '.' + str.slice(1);\n\n                // Avoid '-0'\n                } else if ( u == '0' ) {\n                    return u;\n                }\n            }\n\n            if ( b != null ) {\n\n                if ( !( outOfRange = !( b >= 2 && b < 65 ) ) && ( b == ~~b || !ERRORS ) ) {\n                    str = convertBase( str, b | 0, 10, x['s'] );\n\n                    // Avoid '-0'\n                    if ( str == '0' ) return str;\n                } else {\n\n                    // 'toString() base not an integer: {b}'\n                    // 'toString() base out of range: {b}'\n                    ifExceptionsThrow( b, 'base', 'toS' );\n                }\n            }\n\n        }\n\n        return x['s'] < 0 ? '-' + str : str;\n    };\n\n\n    /*\n     * Return as toString, but do not accept a base argument.\n     */\n    P['valueOf'] = P['toJSON'] = function () {\n        return this.toString();\n    };\n\n\n    // Add aliases for BigDecimal methods.\n    //P['add'] = P['plus'];\n    //P['subtract'] = P['minus'];\n    //P['multiply'] = P['times'];\n    //P['divide'] = P['div'];\n    //P['remainder'] = P['mod'];\n    //P['compareTo'] = P['cmp'];\n    //P['negate'] = P['neg'];\n\n\n    // EXPORT\n\n\n    // Node and other CommonJS-like environments that support module.exports.\n    return BigNumber;\n})();\n"]}